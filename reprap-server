#!/usr/bin/python
# vim: set foldmethod=marker :

import network
import serial
import argparse
import re
import glib

a = argparse.ArgumentParser ()
a.add_argument ('--serial', default = '/dev/ttyACM0', help = 'serial port')
a.add_argument ('--baud', default = 115200, help = 'baud rate', type = int)
a.add_argument ('--network', default = 'reprap|RepRap 3D printer', help = 'network port')
args = a.parse_args ()


class Server:
	# Boring stuff {{{
	def __init__ (self, port, baud):	# {{{
		self.lineno = 0
		self.f_factor = 1.
		self.f_min = 0.
		self.f_max = 120000.
		self.numextruding = 0
		self.printing = False
		self.sdbusy = False
		self.sdstarted = False
		self.relpos = False
		self.erelpos = False
		if port == '':
			self.port = None
			self.extruders = 4
		else:
			self.port = serial.Serial (port, baudrate = baud, timeout = .01)
			self.port.readall ()
			self.port.setTimeout (20)
			for i in range (2):
				if self.port.readline ().strip () == 'start':
					break
			else:
				raise AssertionError ("printer doesn't start")
			glib.io_add_watch (self.port.fileno (), glib.IO_IN | glib.IO_PRI, lambda fd, cond: self.serial_data ())
			info = self.send ('M115')
			assert info is not None
			e = re.findall ('EXTRUDER_COUNT:(\d*)', info)
			if len (e) == 0:
				l = self.port.readline ()
				e = re.findall ('EXTRUDER_COUNT:(\d*)', l)
			self.extruders = int (e[0])
		self.extruding = [0] * self.extruders
		self.e = 0.
		self.diameters = [[3., .5]] * self.extruders
		self.flow = [1.] * self.extruders
		self.temp = [None] * self.extruders
		self.bed = None
		self.send ('G90')
		self.send ('M82')
		self.send ('M21')
		self.currentextruder = 0
		self.send ('G28', retries = 30)
		if self.extruders > 1:
			for e in range (self.extruders):
				self.send ('T%d' % e)
				self.send ('M84')
				self.send ('G92 X0 Y0 Z0 E0')
				self.send ('M104 S0')
			self.send ('T0')
		else:
			self.send ('G92 X0 Y0 Z0 E0')
			self.send ('M104 S0')
		self.send ('M140 S0')
	# }}}
	def serial_data (self):	# {{{
		line = self.port.readline ().strip ()
		if not line.startswith ('//') and line != 'wait':
			print ('Unexpected asynchronous data received from server: %s' % line)
		return True
	# }}}
	def send (self, line, retries = 10):	# {{{
		if ';' in line:
			line = line[:line.index (';')]
		line = line.strip ()
		if line == '':
			return ''
		line = line.upper ()
		words = line.split ()
		codes = {}
		for w in words[1:]:
			codes[w[0]] = w[1:]
		if words[0] in ('G0', 'G1'):
			if 'F' in codes:
				f_orig = float (codes['F'])
				f = f_orig * self.f_factor
				if f < self.f_min:
					f = max (f_orig, self.f_min)
				elif f > self.f_max:
					f = self.f_max
				del codes['F']
				line = words[0] + ' '.join (['%s%f' % (x, float (codes[x])) for x in codes]) + ' F%f' % f
				codes['F'] = True	# The only important thing is that it is defined.
			if 'E' in codes:
				codes['E'] = float (codes['E']) * self.flow[self.currentextruder]
		ret = self._send_impl (line, retries)
		if ret is None or line[0] != 'G':
			if words[0] == 'M82':
				self.erelpos = False
			elif words[0] == 'M83':
				self.erelpos = True
			elif words[0] in ('M104', 'M109'):
				# set extruder temperature.
				self.temp[self.currentextruder] = float (codes['S'])
			elif words[0] == 'M140':
				# set bed temperature.
				self.bed = float (codes['S'])
			# TODO: G10
			elif words[0][0] == 'T':
				self.currentextruder = int (words[0][1:])
			return ret
		if words[0] in ('G0', 'G1'):
			# move
			if 'X' in codes:
				if self.relpos:
					self.x += float (codes['X'])
				else:
					self.x = float (codes['X'])
			if 'Y' in codes:
				if self.relpos:
					self.y += float (codes['Y'])
				else:
					self.y = float (codes['Y'])
			if 'Z' in codes:
				if self.relpos:
					self.z += float (codes['Z'])
				else:
					self.z = float (codes['Z'])
			if 'E' in codes:
				if self.erelpos:
					self.e += codes['E']
				else:
					self.e = codes['E']
			if 'F' in codes:
				self.f = f
		elif words[0] == 'G28':
			# home; not sure where it will go, assume 0.
			if len (codes) == 0:
				self.x = 0.
				self.y = 0.
				self.z = 0.
			else:
				if 'X' in codes:
					self.x = 0.
				if 'Y' in codes:
					self.y = 0.
				if 'Z' in codes:
					self.z = 0.
		elif words[0] == 'G90':
			# absolute
			self.relpos = False
		elif words[0] == 'G91':
			# relative
			self.relpos = True
		elif words[0] == 'G92':
			# set position
			if len (codes) == 0:
				self.x = 0.
				self.y = 0.
				self.z = 0.
				self.e = 0.
			else:
				if 'X' in codes:
					self.x = float (codes['X'])
				if 'Y' in codes:
					self.y = float (codes['Y'])
				if 'Z' in codes:
					self.z = float (codes['Z'])
				if 'E' in codes:
					self.e = float (codes['E'])
		return ret
	# }}}
	def _send_impl (self, line, retries):	# {{{
		assert not self.sdbusy
		checksum = 0
		self.lineno += 1
		ln = 'N%d %s' % (self.lineno, line)
		for x in ln:
			checksum ^= ord (x)
		if not self.port:
			return ''
		self.port.write ('%s*%d\n' % (ln, checksum))
		reply = self.port.readline ()
		while not reply.startswith ('ok'):
			if reply.strip () == 'wait':
				break
			if not reply.startswith ('//'):
				if retries == 0:
					return None
				retries -= 1
			reply = self.port.readline ()
		else:
			return reply[2:].strip ()
		# Something's wrong.  Reset line numbering and retry.
		if retries == 0:
			# Or just give up.
			return None
		self.port.write ('M110 N0\n')
		self.port.readline ()	# "ok"
		self.lineno = 0
		return self._send_impl (line, retries - 1)
	# }}}
	# }}}
	# SD card {{{
	def sdlist (self):	# {{{
		self.sdstarted = False
		return [x.strip () for x in self.send ('M20').split ('{', 1)[1].split ('}', 1)[0].split (',') if x.strip () != '']
	# }}}
	def sdsend (self, file, name = 'TARGET.GCO'):	# {{{
		self.send ('M28 ' + name)
		for line in file.split ('\n'):
			self.send (line.strip ())
		self.send ('M29')
	# }}}
	def sdprint (self, name = 'TARGET.GCO'):	# {{{
		self.send ('M23 ' + name)
		self.send ('M24')
		self.sdbusy = True
		self.sdstarted = True
	# }}}
	def sdpause (self):	# {{{
		assert self.sdbusy
		self.sdbusy = False
		self.send ('M25')
	# }}}
	def sdcontinue (self):	# {{{
		assert self.sdstarted
		self.send ('M24')
		self.sdbusy = True
		self.sdstarted = True
	# }}}
	def sddelete (self, name = 'TARGET.GCO'):	# {{{
		assert not self.sdbusy
		self.send ('M30 ' + name)
		self.sdstarted = False
	# }}}
	# }}}
	# Movement {{{
	def move (self, x = None, y = None, z = None, e = None):	# {{{
		self.goto (None if x is None else self.x + x, None if y is None else self.y + y, None if z is None else self.z + z, e)
	# }}}
	def goto (self, x = None, y = None, z = None, e = None):	# {{{
		if x is None:
			x = self.x
		if y is None:
			y = self.y
		if z is None:
			z = self.z
		if e is None or all ([t == 0 for t in e]):
			self.send ('G1 F%f' % self.f_max)
			if self.relpos:
				self.send ('G1 X%f Y%f Z%f' % (x - self.x, y - self.y, z - self.z))
			else:
				self.send ('G1 X%f Y%f Z%f' % (x, y, z))
		else:
			self.send ('G1 F%f' % (self.f_max / 50))
			which = [t != 0 for t in e]
			assert sum (which) == 1
			w = which.index (True)
			distance = ((x - self.x) ** 2 + (y - self.y) ** 2 + (z - self.z) ** 2) ** .5
			amount = e[w] * distance * self.diameters[w][1] ** 2 / self.diameters[w][0] ** 2
			if not self.erelpos:
				amount += self.e
			if self.relpos:
				self.send ('G1 X%f Y%f Z%f E%f' % (x - self.x, y - self.y, z - self.z, amount))
			else:
				self.send ('G1 X%f Y%f Z%f E%f' % (x, y, z, amount))
	# }}}
	def home (self, only_z = False):	# {{{
		if only_z:
			self.send ('G28 Z0', retries = 30)
		else:
			self.send ('G28', retries = 30)
	# }}}
	def sleep (self):	# {{{
		if self.extruders > 1:
			currentextruder = self.currentextruder
			for e in range (self.extruders):
				self.send ('T%d' % e)
				self.send ('M84')
			self.send ('T%d' % currentextruder)
		else:
			self.send ('M84')
	# }}}
	def wait (self):	# {{{
		self.send ('G4 P0')
	# }}}
	def extrude (self, direction, extruder = 0):	# {{{
		assert not self.printing
		oldnum = self.numextruding
		if (self.extruding[extruder] != 0) != (direction != 0):
			self.numextruding += 1 if direction != 0 else -1
		self.extruding[extruder] = direction
		if oldnum == 0 and self.numextruding > 0:
			glib.idle_add (self.do_extrude)
	# }}}
	def do_extrude (self):	# {{{
		currentextruder = self.currentextruder
		for e in range (self.extruders):
			if self.extruding[e] == 0:
				continue
			if self.currentextruder != e:
				self.send ('T%d' % e)
			self.send ('G1 F%f' % (self.f_max / 10))
			if self.erelpos:
				self.send ('G1 E%d' % self.extruding[e])
			else:
				self.send ('G1 E%f' % (self.e + self.extruding[e]))
			self.send ('G4 P0')
		if currentextruder != self.currentextruder:
			self.send ('T%d' % currentextruder)
		return self.numextruding > 0
	# }}}
	# }}}
	# Temperature {{{
	def temperature (self, degrees, extruder = 0):	# {{{
		if extruder == self.currentextruder:
			self.send ('M104 S%f' % degrees)
		else:
			current = self.currentextruder
			self.send ('T%d' % extruder)
			self.send ('M104 S%f' % degrees)
			self.send ('T%d' % current)
	# }}}
	def bed_temperature (self, degrees):	# {{{
		self.send ('M140 S%f' % degrees)
	# }}}
	# }}}
	# Tweaking {{{
	def feedfactor (self, factor): # {{{
		self.f_factor = factor
	# }}}
	def feedmin (self, value): # {{{
		self.f_min = value
	# }}}
	def feedmax (self, value): # {{{
		self.f_max = value
	# }}}
	def filament_diameter (self, mm, extruder = 0): # {{{
		self.diameters[extruder][0] = mms
	# }}}
	def nozzle_diameter (self, mm, extruder = 0): # {{{
		self.diameters[extruder][1] = mms
	# }}}
	def flowrate (self, factor, extruder = 0): # {{{
		self.flow[int (extruder)] = factor
	# }}}
	def get_config (self):	# {{{
		# Stuff that cannot be changed by G-Code.
		return {'feedmin': self.f_min, 'feedfactor': self.f_factor, 'flowfactor': self.flow, 'feedmax': self.f_max, 'extruders': self.extruders, 'diameter': self.diameters}
	# }}}
	def get_state (self):	# {{{
		# Stuff that can be changed by G-Code or by itself.
		if not self.port:
			temps = {'B': 45, 'T0': 100, 'T1': 123, 'T2': 23, 'T3': 15}
		else:
			state = self.send ('M105')
			if 'B:' not in state:
				for i in range (5):
					state = self.port.readline ()
					if 'B:' in state:
						break
				else:
					raise AssertionError ('No usable reply to request for machine temperature')
			temps = {}
			for x in re.findall ('[BT]\d*:-?[0-9.]+', state):
				k, v = x.split (':')
				temps[k] = float (v)
		etemps = [None] * self.extruders
		if self.extruders != 1:
			for e in range (self.extruders):
				etemps[e] = temps['T%d' % e]
		else:
			etemps[0] = temps['T']
		return {'bed_target': self.bed, 'temperature_target': self.temp, 'bed_current': temps['B'], 'temperature_current': etemps, 'position': (self.x, self.y, self.z)}
	# }}}
	# }}}
	# Printing files {{{
	def do_next_line (self): # {{{
		if not self.printing or len (self.lines) == 0:
			self.printing = False
			return False
		self.send (self.lines.pop (0))
		return True
	# }}}
	def fileprint (self, file):	# {{{
		assert not self.printing
		self.lines = file.split ('\n')
		print 'printing file of %d lines' % len (self.lines)
		self.nextline = 0
		self.printing = True
		glib.idle_add (self.do_next_line)
	# }}}
	def stop (self): # {{{
		assert self.printing
		self.printing = False
	# }}}
	# }}}

serverobj = Server (args.serial, args.baud)
server = network.RPCServer (args.network, lambda socket: serverobj)
#network.bgloop ()
glib.MainLoop ().run ()
