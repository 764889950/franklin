#!/usr/bin/python
# vim: set foldmethod=marker :

import network
import serial
import argparse
import re
import glib

a = argparse.ArgumentParser ()
a.add_argument ('--port', default = '/dev/ttyUSB0', help = 'serial port')
args = a.parse_args ()


class Server:
	# Boring stuff {{{
	def __init__ (self, port):	# {{{
		self.port = serial.Serial (port, baudrate = 115200, timeout = 2)
		assert self.port.readline ().strip () == 'start' or self.port.readline ().strip () == 'start'
		glib.io_add_watch (self.port.fileno (), glib.IO_IN | glib.IO_PRI, lambda fd, cond: self.serial_data ())
		self.lineno = 0
		self.f_factor = 1.
		self.f_min = 12000.
		self.f_max = 120000.
		self.sdbusy = False
		self.sdstarted = False
		self.relpos = False
		self.erelpos = False
		info = self.send ('M115')
		assert info is not None
		e = re.findall ('EXTRUDER_COUNT:(\d*)', info)
		if len (e) == 0:
			l = self.port.readline ()
			e = re.findall ('EXTRUDER_COUNT:(\d*)', l)
		self.extruders = int (e[0])
		self.e = [None] * self.extruders
		self.flow = [1.] * self.extruders
		self.temp = [None] * self.extruders
		self.bed = None
		self.send ('G90')
		self.send ('M82')
		self.send ('M21')
		self.currentextruder = 0
		self.send ('G28', retries = 30)
		if self.extruders > 1:
			for e in range (self.extruders):
				self.send ('T%d' % e)
				self.send ('M84')
				self.send ('G92 X0 Y0 Z0 E0')
				self.send ('M104 S0')
			self.send ('T0')
		else:
			self.send ('G92 X0 Y0 Z0 E0')
			self.send ('M104 S0')
		self.send ('M140 S0')
	# }}}
	def _get_pos (self):	# {{{
		currentextruder = self.currentextruder
		if self.currentextruder != 0:
			self.send ('T0')
		pos = re.match ('^.*?\s*X:(.*?)\s*Y:(.*?)\s*Z:(.*?)\s*E:(.*?)\s*$', self.send ('M114'))
		if pos is None:
			pos = re.match ('^.*?\s*X:(.*?)\s*Y:(.*?)\s*Z:(.*?)\s*E:(.*?)\s*$', self.port.readline ())
		self.x = float (pos.group (1))
		self.y = float (pos.group (2))
		self.z = float (pos.group (3))
		self.e[0] = float (pos.group (4))
		self.temp[0] = 0
		self.f = 0
		self.send ('M105')
		if self.extruders > 1:
			for e in range (1, self.extruders):
				self.send ('T%d' % e)
				pos = re.match ('^.*?\s*X:(.*?)\s*Y:(.*?)\s*Z:(.*?)\s*E:(.*?)\s*$', self.send ('M114'))
				if pos is None:
					pos = re.match ('^.*?\s*X:(.*?)\s*Y:(.*?)\s*Z:(.*?)\s*E:(.*?)\s*$', self.port.readline ())
				self.e[e] = float (pos.group (4))
				self.send ('M105')
			self.send ('T%d' % currentextruder)
	# }}}
	def serial_data (self):	# {{{
		line = self.port.readline ().strip ()
		if not line.startswith ('//') and line != 'wait':
			print ('Unexpected asynchronous data received from server: %s' % line)
		return True
	# }}}
	def send (self, line, retries = 10):	# {{{
		line = line.strip ()
		if line == '' or line.startswith (';'):
			return ''
		line = line.upper ()
		words = line.split ()
		codes = {}
		for w in words[1:]:
			codes[w[0]] = w[1:]
		if words[0] in ('G0', 'G1'):
			if 'F' in codes:
				f_orig = float (codes['F'])
				f = f_orig * self.f_factor
				if f < self.f_min:
					f = max (f_orig, self.f_min)
				elif f > self.f_max:
					f = self.f_max
				del codes['F']
				line = words[0] + ' '.join (['%s%f' % (x, codes[x]) for x in codes]) + ' F%f' % f
				codes['F'] = True	# The only important thing is that it is defined.
			if 'E' in codes:
				codes['E'] = float (codes['E']) * self.flow[self.currentextruder]
		ret = self._send_impl (line, retries)
		if ret is None or line[0] != 'G':
			if words[0] == 'M82':
				self.erelpos = False
			elif words[0] == 'M83':
				self.erelpos = True
			elif words[0] in ('M104', 'M109'):
				# set extruder temperature.
				self.temp[self.currentextruder] = float (codes['S'])
			elif words[0] == 'M140':
				# set bed temperature.
				self.bed = float (codes['S'])
			# TODO: G10
			elif words[0][0] == 'T':
				self.currentextruder = int (words[0][1:])
			return ret
		if words[0] in ('G0', 'G1'):
			# move
			if 'X' in codes:
				if self.relpos:
					self.x += float (codes['X'])
				else:
					self.x = float (codes['X'])
			if 'Y' in codes:
				if self.relpos:
					self.y += float (codes['Y'])
				else:
					self.y = float (codes['Y'])
			if 'Z' in codes:
				if self.relpos:
					self.z += float (codes['Z'])
				else:
					self.z = float (codes['Z'])
			if 'E' in codes:
				if self.erelpos:
					self.e[self.currentextruder] += codes['E']
				else:
					self.e[self.currentextruder] = codes['E']
			if 'F' in codes:
				self.f = f
		elif words[0] == 'G28':
			# home; not sure where it will go, assume 0.
			if len (codes) == 0:
				self.x = 0.
				self.y = 0.
				self.z = 0.
			else:
				if 'X' in codes:
					self.x = 0.
				if 'Y' in codes:
					self.y = 0.
				if 'Z' in codes:
					self.z = 0.
		elif words[0] == 'G90':
			# absolute
			self.relpos = False
		elif words[0] == 'G91':
			# relative
			self.relpos = True
		elif words[0] == 'G92':
			# set position
			if len (codes) == 1:
				self.x = 0.
				self.y = 0.
				self.z = 0.
				for e in self.extruders:
					self.e[e] = 0.
			else:
				if 'X' in codes:
					self.x = float (codes['X'])
				if 'Y' in codes:
					self.y = float (codes['Y'])
				if 'Z' in codes:
					self.z = float (codes['Z'])
				if 'E' in codes:
					self.e[self.currentextruder] = float (codes['E'])
		return ret
	# }}}
	def _send_impl (self, line, retries):	# {{{
		assert not self.sdbusy
		checksum = 0
		self.lineno += 1
		ln = 'N%d %s' % (self.lineno, line)
		for x in ln:
			checksum ^= ord (x)
		self.port.write ('%s*%d\n' % (ln, checksum))
		reply = self.port.readline ()
		while reply.startswith ('//'):
			reply = self.port.readline ()
		while not reply.startswith ('ok'):
			if reply.strip () == 'wait':
				break
			if retries == 0:
				return None
			retries -= 1
			reply = self.port.readline ()
		else:
			return reply[2:].strip ()
		# Something's wrong.  Reset line numbering and retry.
		if retries == 0:
			# Or just give up.
			return None
		self.port.write ('M110 N0\n')
		self.port.readline ()	# "ok"
		self.lineno = 0
		return self._send_impl (line, retries - 1)
	# }}}
	# }}}
	# SD card {{{
	def sdlist (self):	# {{{
		self.sdstarted = False
		return [x.strip () for x in self.send ('M20').split ('{', 1)[1].split ('}', 1)[0].split (',') if x.strip () != '']
	# }}}
	def sdsend (self, file, name = 'TARGET.GCO'):	# {{{
		self.send ('M28 ' + name)
		for line in file.split ('\n'):
			self.send (line.strip ())
		self.send ('M29')
	# }}}
	def sdprint (self, name = 'TARGET.GCO'):	# {{{
		self.send ('M23 ' + name)
		self.send ('M24')
		self.sdbusy = True
		self.sdstarted = True
	# }}}
	def sdpause (self):	# {{{
		assert self.sdbusy
		self.sdbusy = False
		self.send ('M25')
	# }}}
	def sdcontinue (self):	# {{{
		assert self.sdstarted
		self.send ('M24')
		self.sdbusy = True
		self.sdstarted = True
	# }}}
	def sddelete (self, name = 'TARGET.GCO'):	# {{{
		assert not self.sdbusy
		self.send ('M30 ' + name)
		self.sdstarted = False
	# }}}
	# }}}
	# Movement {{{
	def move (self, x = None, y = None, z = None):	# {{{
		if x is None:
			x = 0
		if y is None:
			y = 0
		if z is None:
			z = 0
		self.send ('G1 F%f' % self.f_max)
		if self.relpos:
			self.send ('G1 X%f Y%f Z%f' % (x, y, z))
		else:
			self.send ('G1 X%f Y%f Z%f' % (self.x + x, self.y + y, self.z + z))
	# }}}
	def goto (self, x = None, y = None, z = None):	# {{{
		if x is None:
			x = self.x
		if y is None:
			y = self.y
		if z is None:
			z = self.z
		self.send ('G1 F%f' % self.f_max)
		if self.relpos:
			self.send ('G1 X%f Y%f Z%f' % (x - self.x, y - self.y, z - self.z))
		else:
			self.send ('G1 X%f Y%f Z%f' % (x, y, z))
	# }}}
	def home (self, only_z = False):	# {{{
		if only_z:
			self.send ('G28 Z0', retries = 30)
		else:
			self.send ('G28', retries = 30)
	# }}}
	def sleep (self):	# {{{
		if self.extruders > 1:
			currentextruder = self.currentextruder
			for e in range (self.extruders):
				self.send ('T%d' % e)
				self.send ('M84')
			self.send ('T%d' % currentextruder)
		else:
			self.send ('M84')
	# }}}
	def wait (self):	# {{{
		self.send ('G4 P0')
	# }}}
	def extrude (self, mm, extruder = 0):	# {{{
		if extruder != self.currentextruder:
			self.send ('T%d' % extruder)
		if self.erelpos:
			self.send ('G1 E%f' % mm)
		else:
			self.send ('G1 E%f' % (self.e[self.currentextruder] + mm))
	# }}}
	# }}}
	# Temperature {{{
	def temperature (self, degrees, extruder = 0):	# {{{
		print degrees
		if extruder == self.currentextruder:
			self.send ('M104 S%f' % degrees)
		else:
			current = self.currentextruder
			self.send ('T%d' % extruder)
			self.send ('M104 S%f' % degrees)
			self.send ('T%d' % current)
	# }}}
	def bed (self, degrees):	# {{{
		self.send ('M140 S%f' % degrees)
	# }}}
	# }}}
	# Tweaking {{{
	def feedfactor (self, factor): # {{{
		self.f_factor = factor
	# }}}
	def feedmin (self, value): # {{{
		self.f_min = value
	# }}}
	def feedmax (self, value): # {{{
		self.f_max = value
	# }}}
	def flow (self, factor, extruder = 0): # {{{
		self.flow[extruder] = factor
	# }}}
	def get_config (self):	# {{{
		# Stuff that cannot be changed by G-Code.
		return {'feedmin': self.f_min, 'feedfactor': self.f_factor, 'flowfactor': self.flow, 'feedmax': self.f_max, 'extruders': self.extruders}
	# }}}
	def get_state (self):	# {{{
		# Stuff that can be changed by G-Code or by itself.
		state = self.send ('M105')
		if 'B:' not in state:
			state = self.port.readline ()
			assert 'B:' in state
		temps = {}
		for x in re.findall ('[BT](?:\d*)?:(?:\d|\.)+', state):
			k, v = x.split (':')
			temps[k] = float (v)
		etemps = [None] * self.extruders
		if self.extruders > 0:
			for e in range (self.extruders):
				etemps[e] = temps['T%d' % e]
		else:
			etemps[0] = temps['T0']
		return {'bed_target': self.bed, 'temperature_target': self.temp, 'bed_current': temps['B'], 'temperature_current': etemps, 'position': (self.x, self.y, self.z)}
	# }}}
	# }}}
	# Printing files {{{
	def do_next_line (self): # {{{
		if not self.printing or len (self.lines) == 0:
			self.printing = False
			return False
		self.send (self.lines.pop (0))
		return True
	# }}}
	def print (self, file):	# {{{
		assert not self.printing
		self.lines = file.split ('\n')
		self.nextline = 0
		self.printing = True
		glib.idle_add (self.do_next_line)
	# }}}
	def stop (self): # {{{
		assert self.printing
		self.printing = False
	# }}}
	# }}}

serverobj = Server (args.port)
server = network.RPCServer ('reprap|RepRap 3D printer server', lambda socket: serverobj)
#network.bgloop ()
glib.MainLoop ().run ()
