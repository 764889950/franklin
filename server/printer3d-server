#!/usr/bin/python
# vim: foldmethod=marker :

# Imports. {{{
import re
import os
import sys
import json
import printer3d
import websockets
import xdgbasedir
import glib
import time
from websockets import log
import traceback
# }}}

config = xdgbasedir.config_load (packagename = 'printer3d', defaults = {'port': 8080, 'printer': '', 'audiodir': xdgbasedir.cache_filename_write (packagename = 'printer3d', filename = 'audio', makedirs = False), 'blacklist': r'/dev/(ptmx$|console$|ttyS?\d*)$', 'autodetect': True, 'tls': None})

class Printer:	# {{{
	def _init (self, port):
		resumeinfo = [(yield), None]
		self.printer = printer3d.Printer ()
		c = websockets.call (resumeinfo, self.printer._init, port)
		while c (): c.args = (yield websockets.WAIT)
		self.printer.audiodir = config['audiodir']
		# [axes, extruders, feedrate]
		self.pos = [[0.] * self.printer.get_num_axes (), [0.] * self.printer.get_num_extruders (), float ('inf')]
		self.current_extruder = 0
		self.rel = False
		self.erel = None
		self.etemp = float ('nan')
		self.btemp = float ('nan')
		self.gcode = []
	def home (self, axes = None):
		resumeinfo = [(yield), None]
		self.gcode = []
		if axes is None:
			axes = range (self.printer.get_num_axes ())
		c = websockets.call (resumeinfo, self.printer.home, axes)
		while c (): c.args = (yield websockets.WAIT)
		ret = c.ret ()
		for i, a in enumerate (axes):
			c = websockets.call (resumeinfo, self.printer.axis_get_current_pos, a)
			while c (): c.args = (yield websockets.WAIT)
			self.pos[0][a] = c.ret ()[1]
	def flush (self):
		resumeinfo = [(yield), None]
		c = websockets.call (resumeinfo, self.printer.goto, cb = True)
		while c (): c.args = (yield websockets.WAIT)
		c = websockets.call (resumeinfo, self.printer.wait_for_cb, )
		while c (): c.args = (yield websockets.WAIT)
	def parse_gcode (self, code):
		resumeinfo = [(yield), None]
		self.gcode = []
		for lineno, line in enumerate (code.split ('\n')):
			line = line.strip ()
			if line.startswith ('N'):
				r = re.match ('N\d+\s*(.*?)\*\d+$')
				if not r:
					# Invalid line; ignore it.
					print ('%d:ignoring invalid gcode: %s' % (lineno, line))
					continue
				line = r.group (1)
			if ';' in line:
				line = line[:line.index (';')].strip ()
			if line == '':
				continue
			line = line.split ()
			cmd = line[0][0], int (line[0][1:])
			args = {}
			for a in line[1:]:
				try:
					args[a[0]] = float (a[1:])
				except:
					print ('%d:ignoring invalid gcode: %s' % (lineno, line))
					break
			else:
				self.gcode.append ((cmd, args))
		c = websockets.call (resumeinfo, self.send_gcode)
		while c (): c.args = (yield websockets.WAIT)
	def send_gcode (self):
		resumeinfo = [(yield), None]
		if len (self.gcode) == 0:
			yield False
		while len (self.gcode) > 0 and not self.printer.is_waiting ():
			c = websockets.call (resumeinfo, self.parse_gcode_chunk, *self.gcode.pop (0))
			while c (): c.args = (yield websockets.WAIT)
		yield False
	def parse_gcode_chunk (self, cmd, args):
		resumeinfo = [(yield), None]
		global etemp, btemp, rel, erel
		#print ('Parsing %s %s' % (cmd, args))
		if cmd[0] == 'T':
			# Tool selection.
			target = cmd[1]
			assert len (self.pos[1]) > target
			self.current_extruder = target
		elif cmd[0] == 'G' and cmd[1] in (0, 1):
			components = {'X': None, 'Y': None, 'Z': None, 'E': None, 'F': None}
			for c in args:
				assert c in components and components[c] is None
				components[c] = args[c]
			f0 = self.pos[2]
			if components['F'] is not None:
				self.pos[2] = components['F']
			if components['E'] is not None:
				if self.erel or (self.erel is None and self.rel):
					estep = components['E']
				else:
					estep = components['E'] - self.pos[1][self.current_extruder]
				self.pos[1][self.current_extruder] += estep
			else:
				estep = 0
			oldpos = self.pos[0][:]
			for axis in range (3):
				value = components[chr (ord ('X') + axis)]
				if value is not None:
					if self.rel:
						self.pos[0][axis] += value
					else:
						self.pos[0][axis] = value
			dist = sum ([(self.pos[0][x] - oldpos[x]) ** 2 for x in range (3)]) ** .5
			if dist == 0:
				dist = abs (estep)
			#print ('going to %s estep %s f0 %s dist %s' % (self.pos, estep, f0, dist))
			if dist > 0:
				#if f0 is None:
				#	f0 = self.pos[1][self.current_extruder]
				f0 = self.pos[2]	# Use new value.
				if f0 == 0:
					f0 = float ('inf')
				c = websockets.call (resumeinfo, self.printer.goto, axes = {0: self.pos[0][0], 1: self.pos[0][1], 2: self.pos[0][2]}, e = estep, f0 = f0 / dist / 60, f1 = self.pos[2] / dist / 60, cb = False)
				while c (): c.args = (yield websockets.WAIT)
				#self.printer.wait_for_cb ()
		elif cmd == ('G', 28):
			c = websockets.call (resumeinfo, self.flush)
			while c (): c.args = (yield websockets.WAIT)
			which = ''
			for w in args:
				which += w
			if which == '':
				which = 'XYZ'
			axes = [ord (w) - ord ('X') for w in which]
			gcode = self.gcode
			c = websockets.call (resumeinfo, self.home, axes)
			while c (): c.args = (yield websockets.WAIT)
			self.gcode = gcode
		elif cmd == ('G', 4):
			c = websockets.call (resumeinfo, self.flush)
			while c (): c.args = (yield websockets.WAIT)
			if 'P' in args:
				time.sleep (args['P'] / 1000) # TODO
		elif cmd == ('G', 21):
			pass
		elif cmd == ('G', 90):
			self.rel = False
		elif cmd == ('G', 91):
			self.rel = True
		elif cmd == ('G', 92):
			which = {}
			for w in args:
				if w in 'XYZ':
					wh = ord (w) - ord ('X')
					self.pos[0][wh] = args[w]
					which[wh] = args[w]
				elif w == 'E':
					self.pos[1][self.current_extruder] = args[w]
			if len (which) > 0:
				c = websockets.call (resumeinfo, self.flush)
				while c (): c.args = (yield websockets.WAIT)
				for w in which:
					c = websockets.call (resumeinfo, self.printer.axis_set_current_pos, w, which[w])
					while c (): c.args = (yield websockets.WAIT)
		elif cmd == ('M', 42):
			pin = args['P']
			value = args['S']
			c = websockets.call (resumeinfo, self.printer.settemp_temp, pin, value)
			while c (): c.args = (yield websockets.WAIT)
		elif cmd == ('M', 82):
			self.erel = False
		elif cmd == ('M', 83):
			self.erel = True
		elif cmd == ('M', 84):
			c = websockets.call (resumeinfo, self.flush)
			while c (): c.args = (yield websockets.WAIT)
			for axis in range (3):
				c = websockets.call (resumeinfo, self.printer.sleep_axis, axis)
				while c (): c.args = (yield websockets.WAIT)
			c = websockets.call (resumeinfo, self.printer.sleep_extruder, 0)
			while c (): c.args = (yield websockets.WAIT)
		elif cmd == ('M', 104):
			c = websockets.call (resumeinfo, self.flush)
			while c (): c.args = (yield websockets.WAIT)
			self.etemp = args['S']
			c = websockets.call (resumeinfo, self.printer.settemp_extruder, 0, self.etemp)
			while c (): c.args = (yield websockets.WAIT)
		elif cmd == ('M', 106):	# Fan on
			#c = websockets.call (resumeinfo, self.flush)
			#while c (): c.args = (yield websockets.WAIT)
			#c = websockets.call (resumeinfo, self.printer.settemp_temp, 1, float ('inf'))
			#while c (): c.args = (yield websockets.WAIT)
			pass
		elif cmd == ('M', 107):
			#c = websockets.call (resumeinfo, self.flush)
			#while c (): c.args = (yield websockets.WAIT)
			#c = websockets.call (resumeinfo, self.printer.settemp_temp, 1, float ('nan'))
			#while c (): c.args = (yield websockets.WAIT)
			pass
		elif cmd == ('M', 109):
			c = websockets.call (resumeinfo, self.flush)
			while c (): c.args = (yield websockets.WAIT)
			self.etemp = args['S']
			c = websockets.call (resumeinfo, self.printer.settemp_extruder, 0, self.etemp)
			while c (): c.args = (yield websockets.WAIT)
			if self.printer.pin_valid (self.printer.extruder_temp_get_thermistor_pin (0)):
				c = websockets.call (resumeinfo, self.printer.waittemp_extruder, 0, self.etemp, float ('nan'))
				while c (): c.args = (yield websockets.WAIT)
		elif cmd == ('M', 116):
			c = websockets.call (resumeinfo, self.flush)
			while c (): c.args = (yield websockets.WAIT)
			if self.printer.pin_valid (self.printer.extruder_temp_get_thermistor_pin (0)):
				c = websockets.call (resumeinfo, self.printer.waittemp_extruder, 0, self.etemp, float ('nan'))
				while c (): c.args = (yield websockets.WAIT)
			if self.printer.pin_valid (self.printer.temp_get_thermistor_pin (0)):
				c = websockets.call (resumeinfo, self.printer.waittemp_temp, 0, self.btemp, float ('nan'))
				while c (): c.args = (yield websockets.WAIT)
		elif cmd == ('M', 140):
			c = websockets.call (resumeinfo, self.flush)
			while c (): c.args = (yield websockets.WAIT)
			self.btemp = args['S']
			c = websockets.call (resumeinfo, self.printer.settemp_temp, 0, self.btemp)
			while c (): c.args = (yield websockets.WAIT)
		elif cmd == ('M', 190):
			c = websockets.call (resumeinfo, self.flush)
			while c (): c.args = (yield websockets.WAIT)
			if 'S' in args:
				self.btemp = args['S']
				c = websockets.call (resumeinfo, self.printer.settemp_temp, 0, self.btemp)
				while c (): c.args = (yield websockets.WAIT)
			if self.printer.pin_valid (self.printer.temp_get_thermistor_pin (0)):
				c = websockets.call (resumeinfo, self.printer.waittemp_temp, 0, self.btemp, float ('nan'))
				while c (): c.args = (yield websockets.WAIT)
		else:
			raise SyntaxError ('invalid gcode command %s' % cmd)
# }}}

class Connection: # {{{
	def __init__ (self, socket):
		self.socket = socket
		self.printer = self.find_printer (*default_printer)
	@classmethod
	def find_printer (cls, name = None, port = None):
		for p in ports:
			if (name is None or re.match (name, ports[p].printer.name)) and (port is None or re.match (port, p)):
				return ports[p]
		return None
	@classmethod
	def set_autodetect (cls, detect):
		global autodetect
		autodetect = detect
	@classmethod
	def disable (cls, port):
		assert port in ports
		if ports[port]:
			return
		# Close the serial connection.
		ports[port].printer.printer.close ()
		# Forget the printer.
		ports[port] = None
	@classmethod
	def detect (cls, port):
		resumeinfo = [(yield), None]
		assert port in ports and ports[port] is None
		log ('detecting printer on %s' % port)
		try:
			ports[port] = False
			p = Printer ()
			c = websockets.call (resumeinfo, p._init, port)
			while c (): c.args = (yield websockets.WAIT)
			ports[port] = p
			log ('detected printer %s on %s' % (p.printer.name, port))
		except:
			log ('no printer found on port %s' % port)
			ports[port] = None
			traceback.print_exc ()
			return
	@classmethod
	def detect_all (cls):
		resumeinfo = [(yield), None]
		for p in ports:
			if ports[p] is not None:
				continue
			c = websockets.call (resumeinfo, cls.detect, p)
			while c (): c.args = (yield websockets.WAIT)
	@classmethod
	def add_port (cls, port):
		resumeinfo = [(yield), None]
		assert port not in ports
		if re.match (blacklist, port):
			#log ('skipping blacklisted port %s' % port)
			return
		ports[port] = None
		if autodetect:
			c = websockets.call (resumeinfo, cls.detect, port)
			while c (): c.args = (yield websockets.WAIT)
	@classmethod
	def remove_port (cls, port):
		if port not in ports:
			return
		if ports[port]:
			# Close serial port, in case it still exists.
			ports[port].printer.printer.close ()
			#orphans.append (ports[port])
		del ports[port]
	@classmethod
	def get_ports (cls):
		return [(p, ports[p].printer.name if ports[p] is not None else None) for p in ports]
	@classmethod
	def set_default_printer (cls, name = None, port = None):
		global default_printer
		default_printer = (name, port)
	@classmethod
	def get_default_printer (cls):
		return default_printer
	@classmethod
	def set_blacklist (cls, newlist):
		global blacklist
		blacklist = newlist
	@classmethod
	def get_blacklist (cls):
		return blacklist
	def set_printer (self, printer = None, port = None):
		self.printer = self.find_printer (printer, port)
	def get_printer (self):
		return self.printer.printer.name if self.printer is not None else None
	def gcode (self, code):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		log ('gcode')
		c = websockets.call (resumeinfo, self.printer.parse_gcode, code)
		while c (): c.args = (yield websockets.WAIT)
	def home_all (self):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		self.printer.gcode = []
		c = websockets.call (resumeinfo, self.printer.home, )
		while c (): c.args = (yield websockets.WAIT)
	def home_z (self):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		self.printer.gcode = []
		c = websockets.call (resumeinfo, self.printer.home, [2])
		while c (): c.args = (yield websockets.WAIT)
	def sleep_all (self):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		self.printer.gcode = []
		for a in range (self.printer.printer.get_num_axes ()):
			c = websockets.call (resumeinfo, self.printer.printer.sleep_axis, a)
			while c (): c.args = (yield websockets.WAIT)
		for e in range (self.printer.printer.get_num_extruders ()):
			c = websockets.call (resumeinfo, self.printer.printer.sleep_extruder, e)
			while c (): c.args = (yield websockets.WAIT)
	def status (self):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		c = websockets.call (resumeinfo, self.printer.printer.readtemp_temp, 0)
		while c (): c.args = (yield websockets.WAIT)
		t = c.ret ()
		c = websockets.call (resumeinfo, self.printer.printer.readtemp_extruder, 0)
		while c (): c.args = (yield websockets.WAIT)
		yield (t, c.ret ())
	def __getattr__ (self, attr):
		#log ('other: %s' % attr)
		assert self.printer is not None
		return getattr (self.printer.printer, attr)
# }}}

default_printer = (None, None)
ports = {}
autodetect = config['autodetect']
blacklist = config['blacklist']
if autodetect:
	# Assume a GNU/Linux system; if you have something else, you need to come up with a way to iterate over all your serial ports and implement it here.  Patches welcome, especially if they are platform-independent.
	if os.path.exists ('/sys/class/tty'):
		for tty in os.listdir ('/sys/class/tty'):
			websockets.call (None, Connection.add_port, '/dev/' + tty) ()

if ' ' in config['printer']:
	default_printer = config['printer'].rsplit (' ', 1)
else:
	default_printer = (config['printer'], None)

httpd = websockets.RPChttpd (config['port'], Connection, httpdirs = xdgbasedir.data_files_read ('html', packagename = 'printer3d'), tls = config['tls'])

log ('running')
websockets.fgloop ()
