#!/usr/bin/python
# vim: foldmethod=marker :

# Imports. {{{
import re
import os
import sys
import math
import random
import json
import printer3d
import websockets
import xdgbasedir
import glib
import subprocess
import crypt
import time
from websockets import log
import traceback
# }}}

config = xdgbasedir.config_load (packagename = 'printer3d', defaults = {'port': 8080, 'address': '', 'printer': '', 'audiodir': xdgbasedir.cache_filename_write (packagename = 'printer3d', filename = 'audio', makedirs = False), 'blacklist': r'/dev/(ptmx$|console$|ttyS?\d*)$', 'autodetect': 'True', 'avrdude': '/usr/bin/avrdude', 'login': '', 'passwordfile': '', 'done': ''})

class Printer:	# {{{
	def _init (self, port, broadcast, death):
		resumeinfo = [(yield), None]
		self.signals = {}
		self.confirmer = None
		self.printer = printer3d.Printer ()
		# Provide easy access to some useful data.
		self.printer.id_map = ''.join ([chr (x) for x in id_map])
		self.printer.audiodir = config['audiodir']
		# Initialize the printer.
		c = websockets.call (resumeinfo, self.printer._init, port, broadcast, death, orphans, nextid ())
		while c (): c.args = (yield websockets.WAIT)
		printer = c.ret ()
		if printer is False:
			# Not really an error, but we need to raise an exception.
			raise ValueError ('printer not found')
		if printer is not True:
			# An orphan has reconnected.
			ports[port] = printer
			orphans.pop (printer.printer.printerid)
			c = websockets.call (resumeinfo, printer.printer._reconnect, port, self.printer.printer)
			while c (): c.args = (yield websockets.WAIT)
			yield printer
		self._gcode = []
	def request_confirmation (self, message):
		resumeinfo = [(yield), None]
		Connection._broadcast (None, 'confirm', self.printer.port, message)
		self.confirmer = resumeinfo[0]
		yield (yield websockets.WAIT)
	def confirm (self, success = True):
		c = self.confirmer
		self.confirmer = None
		if c is not None:
			c (success)
	def home (self, axes = None, keep_gcode = False):
		resumeinfo = [(yield), None]
		if not keep_gcode:
			if len (self._gcode) > 0:
				print ('flushing pending gcode')
				print_done (self.printer.port, False, 'aborted by home command')
			else:
				print ('no gcode pending')
		if axes is None:
			axes = range (self.printer.get_num_axes ())
		c = websockets.call (resumeinfo, self.printer.home, axes)
		while c (): c.args = (yield websockets.WAIT)
	def flush (self):
		resumeinfo = [(yield), None]
		c = websockets.call (resumeinfo, self.printer.goto, cb = True)
		while c (): c.args = (yield websockets.WAIT)
		c = websockets.call (resumeinfo, self.printer.wait_for_cb, )
		while c (): c.args = (yield websockets.WAIT)
	def gcode (self, code, ref = (0, 0), angle = 0):
		resumeinfo = [(yield), None]
		c = websockets.call (resumeinfo, self.gcode_parse, code)
		while c (): c.args = (yield websockets.WAIT)
		c = websockets.call (resumeinfo, self.gcode_run, c.ret (), ref, angle)
		while c (): c.args = (yield websockets.WAIT)
	def gcode_run (self, code, ref = (0, 0), angle = 0):
		btemp = self.printer.temp[0].value
		resumeinfo = [(yield), None]
		if len (self._gcode) > 0:
			print_done (self.printer.port, False, 'aborted by starting new print')
		self._gcode = code[:]
		if len (self._gcode) <= 0:
			log ('nothing to run')
			yield False
		Connection._broadcast (None, 'printing', self.printer.port, True)
		while len (self._gcode) > 0:
			cmd, args, message = self._gcode.pop (0)
			cmd = tuple (cmd)
			#log ('Running %s %s' % (cmd, args))
			if cmd[0] == 'S':
				# Spindle speed; not supported, but shouldn't error.
				pass
			elif cmd == ('G', 1):
				#log (repr (args))
				cosa = math.cos (angle)
				sina = math.sin (angle)
				target = cosa * args['X'] + sina * args['Y'] + ref[0], cosa * args['Y'] - sina * args['X'] + ref[1]
				c = websockets.call (resumeinfo, self.printer.goto, [target[0], target[1], args['Z']], e = args['E'], f0 = args['f'], f1 = args['F'])
				while c (): c.args = (yield websockets.WAIT)
			elif cmd == ('G', 28):
				c = websockets.call (resumeinfo, self.flush)
				while c (): c.args = (yield websockets.WAIT)
				which = ''
				for w in args:
					which += w
				if which == '':
					which = 'XYZ'
				axes = [x for x in [ord (w) - ord ('X') for w in which] if not self.printer.axis_valid (x)]
				if len (axes) > 0:
					c = websockets.call (resumeinfo, self.home, axes, True)
					while c (): c.args = (yield websockets.WAIT)
			elif cmd == ('G', 4):
				c = websockets.call (resumeinfo, self.flush)
				while c (): c.args = (yield websockets.WAIT)
				if 'P' in args:
					handle = glib.timeout_add (int (args['P']), lambda: resumeinfo[0] () is None and False) # Make sure the lambda function returns False.
					yield websockets.WAIT
					glib.source_remove (handle) # Just to be sure.  No error if it was already gone.
			elif cmd == ('G', 94):
				# Set feed rate mode to units per minute; we don't support anything else, but shouldn't error on this request.
				pass
			elif cmd == ('M', 0):
				# Wait.
				c = websockets.call (resumeinfo, self.request_confirmation, message)
				while c (): c.args = (yield websockets.WAIT)
				if not c.ret ():
					yield False
			elif cmd[0] == 'M' and cmd[1] in (3, 4):
				# Start spindle; we don't support speed or direction, so M3 and M4 are equal.
				c = websockets.call (resumeinfo, self.printer.gpio_set_state, 0, 3)
				while c (): c.args = (yield websockets.WAIT)
			elif cmd == ('M', 5):
				# Stop spindle.
				c = websockets.call (resumeinfo, self.printer.gpio_set_state, 0, 0)
				while c (): c.args = (yield websockets.WAIT)
			elif cmd == ('M', 6):
				# Tool change.  Move pcb away from spindle.
				c = websockets.call (resumeinfo, self.printer.goto, [0, 0, min ([self.printer.axis_get_limit_max_pos (a) - 3 for a in range (3)])])
				while c (): c.args = (yield websockets.WAIT)
			elif cmd == ('M', 9):
				# Coolant off.  We don't support coolant, but turning it off is not an error.
				pass
			elif cmd == ('M', 42):
				g = args['P']
				value = args['S']
				c = websockets.call (resumeinfo, self.printer.gpio_set_state, int (g), int (value))
				while c (): c.args = (yield websockets.WAIT)
			elif cmd == ('M', 84):
				c = websockets.call (resumeinfo, self.flush)
				while c (): c.args = (yield websockets.WAIT)
				for axis in range (self.printer.num_axes):
					c = websockets.call (resumeinfo, self.printer.sleep_axis, axis)
					while c (): c.args = (yield websockets.WAIT)
				for extruder in range (self.printer.num_extruders):
					c = websockets.call (resumeinfo, self.printer.sleep_extruder, extruder)
					while c (): c.args = (yield websockets.WAIT)
			elif cmd == ('M', 104):
				c = websockets.call (resumeinfo, self.flush)
				while c (): c.args = (yield websockets.WAIT)
				c = websockets.call (resumeinfo, self.printer.settemp_extruder, args['E'], args['S'])
				while c (): c.args = (yield websockets.WAIT)
			elif cmd == ('M', 106):	# Fan on
				c = websockets.call (resumeinfo, self.flush)
				while c (): c.args = (yield websockets.WAIT)
				c = websockets.call (resumeinfo, self.printer.gpio_set_state, 0, 3)
				while c (): c.args = (yield websockets.WAIT)
				pass
			elif cmd == ('M', 107): # Fan off
				c = websockets.call (resumeinfo, self.flush)
				while c (): c.args = (yield websockets.WAIT)
				c = websockets.call (resumeinfo, self.printer.gpio_set_state, 0, 2)
				while c (): c.args = (yield websockets.WAIT)
				pass
			elif cmd == ('M', 109):
				c = websockets.call (resumeinfo, self.flush)
				while c (): c.args = (yield websockets.WAIT)
				e = args['E']
				if 'S' in args:
					c = websockets.call (resumeinfo, self.printer.settemp_extruder, e, args['S'])
					while c (): c.args = (yield websockets.WAIT)
				else:
					args['S'] = self.printer.extruder[e].temp.value
				if not math.isnan (args['S']) and self.printer.pin_valid (self.printer.extruder_temp_get_thermistor_pin (e)):
					self.printer.clear_alarm ()
					c = websockets.call (resumeinfo, self.printer.waittemp_extruder, e, args['S'])
					while c (): c.args = (yield websockets.WAIT)
					c = websockets.call (resumeinfo, self.printer.wait_for_temp_extruder, e)
					while c (): c.args = (yield websockets.WAIT)
			elif cmd == ('M', 116):
				c = websockets.call (resumeinfo, self.flush)
				while c (): c.args = (yield websockets.WAIT)
				e = args['E']
				etemp = self.printer.extruder[e].temp.value
				if not math.isnan (etemp) and self.printer.pin_valid (self.printer.extruder_temp_get_thermistor_pin (e)):
					self.printer.clear_alarm ()
					c = websockets.call (resumeinfo, self.printer.waittemp_extruder, e, etemp)
					while c (): c.args = (yield websockets.WAIT)
					c = websockets.call (resumeinfo, self.printer.wait_for_temp_extruder, e)
					while c (): c.args = (yield websockets.WAIT)
				if not math.isnan (btemp) and self.printer.pin_valid (self.printer.temp_get_thermistor_pin (0)):
					self.printer.clear_alarm ()
					c = websockets.call (resumeinfo, self.printer.waittemp_temp, 0, btemp)
					while c (): c.args = (yield websockets.WAIT)
					c = websockets.call (resumeinfo, self.printer.wait_for_temp_temp, 0)
					while c (): c.args = (yield websockets.WAIT)
			elif cmd == ('M', 140):
				c = websockets.call (resumeinfo, self.flush)
				while c (): c.args = (yield websockets.WAIT)
				btemp = args['S']
				c = websockets.call (resumeinfo, self.printer.settemp_temp, 0, btemp)
				while c (): c.args = (yield websockets.WAIT)
			elif cmd == ('M', 190):
				c = websockets.call (resumeinfo, self.flush)
				while c (): c.args = (yield websockets.WAIT)
				if 'S' in args:
					btemp = args['S']
					c = websockets.call (resumeinfo, self.printer.settemp_temp, 0, btemp)
					while c (): c.args = (yield websockets.WAIT)
				if not math.isnan (btemp) and self.printer.pin_valid (self.printer.temp_get_thermistor_pin (0)):
					c = websockets.call (resumeinfo, self.printer.waittemp_temp, 0, btemp)
					while c (): c.args = (yield websockets.WAIT)
		c = websockets.call (resumeinfo, self.flush)
		while c (): c.args = (yield websockets.WAIT)
		print_done (self.printer.port, True, 'completed')
		yield False
# }}}

def gcode_parse (code): # {{{
	mode = None
	message = None
	ret = []
	unit = 1
	rel = False
	erel = None
	pos = [[0., 0., 0.], [0.], float ('inf')]
	current_extruder = 0
	for lineno, origline in enumerate (code.split ('\n')):
		line = origline.strip ()
		if line.startswith ('N'):
			r = re.match ('N\d+\s*(.*?)\*\d+$')
			if not r:
				# Invalid line; ignore it.
				log ('%d:ignoring invalid gcode: %s' % (lineno, origline))
				continue
			line = r.group (1)
		comment = ''
		while '(' in line:
			b = line.index ('(')
			e = line.find (')', b)
			if e < 0:
				log ('%d:ignoring unterminated comment: %s' % (lineno, origline))
				continue
			comment = line[b + 1:e].strip ()
			line = line[:b] + line[e + 1:].strip ()
		if ';' in line:
			p = line.index (';')
			comment = line[p + 1:].strip ()
			line = line[:p].strip ()
		if comment.upper ().startswith ('MSG,'):
			message = comment[4:].strip ()
		if line == '':
			continue
		line = line.split ()
		if mode is None or line[0][0] in 'GMT':
			cmd = line[0][0], int (line[0][1:])
			line = line[1:]
		else:
			cmd = mode
		args = {}
		for a in line:
			try:
				args[a[0]] = float (a[1:])
			except:
				log ('%d:ignoring invalid gcode: %s' % (lineno, origline))
				break
		else:
			if cmd == ('M', 2):
				# Program end.
				break
			elif cmd[0] == 'T':
				target = cmd[1]
				if target >= len (pos[1]):
					pos[1].extend ([0.] * (target - len (pos[1]) + 1))
				current_extruder = target
				continue
			elif cmd == ('G', 20):
				unit = 25.4
				continue
			elif cmd == ('G', 21):
				unit = 1
				continue
			elif cmd == ('G', 90):
				rel = False
				continue
			elif cmd == ('G', 91):
				rel = True
				continue
			elif cmd == ('M', 82):
				erel = False
				continue
			elif cmd == ('M', 83):
				erel = True
				continue
			elif cmd == ('G', 92):
				which = {}
				for w in args:
					if w in 'XYZ':
						# Ignore; this is only abused.
						pass
					elif w == 'E':
						pos[1][current_extruder] = args[w]
				continue
			elif cmd[0] == 'M' and cmd[1] in (104, 109, 116):
				args['E'] = current_extruder
			if not ((cmd[0] == 'G' and cmd[1] in (0, 1, 4, 28, 81, 94)) or (cmd[0] == 'M' and cmd[1] in (0, 3, 4, 5, 6, 9, 42, 84, 104, 106, 107, 109, 116, 140, 190)) or (cmd[0] in ('S', 'T'))):
				log ('%d:invalid gcode command %s' % (lineno, repr ((cmd, args))))
			elif cmd[0] == 'G' and cmd[1] in (0, 1, 81):
				mode = cmd
				components = {'X': None, 'Y': None, 'Z': None, 'E': None, 'F': None, 'R': None}
				for c in args:
					assert c in components and components[c] is None
					components[c] = args[c]
				f0 = pos[2]
				if components['F'] is not None:
					pos[2] = components['F'] * unit
				if cmd[1] != 81:
					if components['E'] is not None:
						if erel or (erel is None and rel):
							estep = components['E'] * unit
						else:
							estep = components['E'] * unit - pos[1][current_extruder]
						pos[1][current_extruder] += estep
					else:
						estep = 0
				else:
					estep = 0
					if components['R'] is not None:
						if rel:
							r = pos[0][2] + components['R'] * unit
						else:
							r = components['R'] * unit
				oldpos = pos[0][:]
				for axis in range (3):
					value = components[chr (ord ('X') + axis)]
					if value is not None:
						if rel:
							pos[0][axis] += value * unit
						else:
							pos[0][axis] = value * unit
						if axis == 2:
							z = pos[0][2]
				if cmd[1] != 81:
					dist = sum ([(pos[0][x] - oldpos[x]) ** 2 for x in range (3)]) ** .5
					if dist == 0:
						dist = abs (estep)
					if dist > 0:
						#if f0 is None:
						#	f0 = pos[1][current_extruder]
						f0 = pos[2]	# Always use new value.
						if f0 == 0:
							f0 = float ('inf')
					args = {'X': pos[0][0], 'Y': pos[0][1], 'Z': pos[0][2], 'E': estep, 'f': f0 / dist / 60 if dist != 0 and cmd[1] == 1 else float ('inf'), 'F': pos[2] / dist / 60 if dist != 0 and cmd[1] == 1 else float ('inf')}
					cmd = ('G', 1)
					ret.append ((cmd, args, message))
				else:
					# Drill cycle.
					# Only support OLD_Z (G90) retract mode; don't support repeats (L).
					# goto x,y
					ret.append ((('G', 1), {'X': pos[0][0], 'Y': pos[0][1], 'Z': oldpos[2], 'E': 0, 'f': float ('inf'), 'F': float ('inf')}, message))
					# goto r
					ret.append ((('G', 1), {'X': pos[0][0], 'Y': pos[0][1], 'Z': r, 'E': 0, 'f': float ('inf'), 'F': float ('inf')}, None))
					# goto z; this is always straight down, because the move before and after it are also vertical.
					if z != r:
						f0 = pos[2] / abs (z - r) / 60
						ret.append ((('G', 1), {'X': pos[0][0], 'Y': pos[0][1], 'Z': z, 'E': 0, 'f': f0, 'F': f0}, None))
					# retract; this is always straight up, because the move before and after it are also non-horizontal.
					ret.append ((('G', 1), {'X': pos[0][0], 'Y': pos[0][1], 'Z': oldpos[2], 'E': 0, 'f': float ('inf'), 'F': float ('inf')}, None))
					# empty move; this makes sure the previous move is entirely vertical.
					ret.append ((('G', 1), {'X': pos[0][0], 'Y': pos[0][1], 'Z': oldpos[2], 'E': 0, 'f': float ('inf'), 'F': float ('inf')}, None))
					# Set up current z position so next G81 will work.
					pos[0][2] = oldpos[2]
			else:
				ret.append ((cmd, args, message))
			message = None
	return ret
# }}}

def gcode_bbox (code): # {{{
	ret = [[None, None], [None, None], [None, None]]
	def inspect (value, box):
		if box[0] is None or value < box[0]:
			box[0] = value
		if box[1] is None or value > box[1]:
			box[1] = value
	for cmd, args, message in code:
		if cmd[0] != 'G' or cmd[1] not in (0, 1, 81):
			continue
		inspect (args['X'], ret[0])
		inspect (args['Y'], ret[1])
		if 'Z' in args:
			inspect (args['Z'], ret[2])
		if 'R' in args:
			inspect (args['R'], ret[2])
	return ret
# }}}

class Connection: # {{{
	def __init__ (self, socket):
		socket.monitor = False
		self.socket = socket
		self.printer = self.find_printer (*default_printer)
	@classmethod
	def _broadcast (cls, target, name, *args):
		if target:
			if target.monitor:
				getattr (target, name).event (*args)
		elif httpd:
				for c in httpd.websockets:
					if c.monitor:
						getattr (c, name).event (*args)
	@classmethod
	def upload (cls, port, board):
		resumeinfo = [(yield), None]
		cls.disable (port)
		if board == 'melzi':
			protocol = 'arduino'
			baudrate = '115200'
			mcu = 'atmega1284p'
			filename = xdgbasedir.data_files_read (os.path.join ('firmware', 'mighty_opt.hex'), packagename = 'printer3d')[0]
		elif board == 'ramps':
			protocol = 'wiring'
			baudrate = '115200'
			mcu = 'atmega2560'
			filename = xdgbasedir.data_files_read (os.path.join ('firmware', 'mega2560.hex'), packagename = 'printer3d')[0]
		elif board == 'mega':
			protocol = 'arduino'
			baudrate = '57600'
			mcu = 'atmega1280'
			filename = xdgbasedir.data_files_read (os.path.join ('firmware', 'mega.hex'), packagename = 'printer3d')[0]
		else:
			raise ValueError ('board type not supported')
		process = subprocess.Popen ([config['avrdude'], '-V', '-c', protocol, '-b', baudrate, '-p', mcu, '-P', port, '-U', 'flash:w:' + filename], stdin = subprocess.PIPE, stdout = subprocess.PIPE, stderr = subprocess.STDOUT)
		glib.io_add_watch (process.stdout, glib.IO_IN | glib.IO_PRI | glib.IO_HUP, lambda fd, cond: cls._upload_output (process.stdout, resumeinfo))
		yield websockets.WAIT
		if autodetect:
			c = websockets.call (resumeinfo, cls.detect, port)
			while c (): c.args = (yield websockets.WAIT)
		yield process.wait ()
	@classmethod
	def _upload_output (cls, pipe, resumeinfo):
		data = pipe.read ()
		if data != '':
			return True
		resumeinfo[0] ()
		return False
	@classmethod
	def find_printer (cls, name = None, port = None):
		for p in ports:
			if not ports[p]:
				continue
			if (name is None or re.match (name, ports[p].printer.name)) and (port is None or re.match (port, p)):
				return ports[p]
		return None
	@classmethod
	def set_autodetect (cls, detect):
		global autodetect
		autodetect = detect
		cls._broadcast (None, 'autodetect', autodetect)
	@classmethod
	def get_autodetect (cls):
		return autodetect
	@classmethod
	def disable (cls, port):
		if port not in ports or not ports[port]:
			#log ('port is not enabled')
			return
		# Close the serial connection.
		ports[port].printer._close ()
		# Forget the printer.
		ports[port] = None
		cls._broadcast (None, 'del_printer', port)
	@classmethod
	def detect (cls, port):
		resumeinfo = [(yield), None]
		#log ('detecting printer on %s' % port)
		if port not in ports or ports[port] != None:
			#log ('port is not in detectable state')
			return
		try:
			ports[port] = False
			p = Printer ()
			def death (port):
				if ports[port] is False:
					# Printer was still being set up; just ignore it.
					ports[port] = None
				else:
					# If there already is an orphan with the same name, kill the old orphan.
					for o in [x for x in orphans if orphans[x].printer.name == ports[port].printer.name]:
						# This for loop always runs 0 or 1 times, never more.
						del orphans[x]
					orphans[ports[port].printer.printerid] = ports[port]
					cls.disable (port)
				if autodetect:
					websockets.call (None, cls.detect, port) ()
			c = websockets.call (resumeinfo, p._init, port, cls._broadcast, death)
			while c (): c.args = (yield websockets.WAIT)
			r = c.ret ()
			if r:
				# This was a orphan, which has now been adopted.
				p = r
				#log ('adopted printer %s on %s' % (p.printer.name, port))
			else:
				ports[port] = p
				#log ('detected printer %s on %s' % (p.printer.name, port))
			cls._send_printer (None, p.printer)
		except:
			log ('no printer found on port %s' % port)
			ports[port] = None
			traceback.print_exc ()
			return
	@classmethod
	def _send_printer (cls, target, printer):
		cls._broadcast (target, 'new_printer', printer.port, [printer.namelen, printer.maxaxes, printer.maxextruders, printer.maxtemps, printer.maxgpios, printer.audio_fragments, printer.audio_fragment_size, printer.num_digital_pins, printer.num_pins])
		printer._variables_update (target)
		for a in range (printer.maxaxes):
			printer._axis_update (a, target)
		for e in range (printer.maxextruders):
			printer._extruder_update (e, target)
		for t in range (printer.maxtemps):
			printer._temp_update (t, target)
		for g in range (printer.maxgpios):
			printer._gpio_update (g, target)
		if len (ports[printer.port]._gcode) > 0:
			cls._broadcast (target, 'printing', printer.port, True)
	@classmethod
	def detect_all (cls):
		resumeinfo = [(yield), None]
		for p in ports:
			if ports[p] is not None:
				continue
			c = websockets.call (resumeinfo, cls.detect, p)
			while c (): c.args = (yield websockets.WAIT)
	@classmethod
	def add_port (cls, port):
		resumeinfo = [(yield), None]
		if port in ports:
			log ('already existing port %s cannot be added' % port)
			return
		if re.match (blacklist, port):
			#log ('skipping blacklisted port %s' % port)
			return
		ports[port] = None
		cls._broadcast (None, 'new_port', port);
		if autodetect:
			c = websockets.call (resumeinfo, cls.detect, port)
			while c (): c.args = (yield websockets.WAIT)
	@classmethod
	def remove_port (cls, port):
		print ('removing port %s' % port)
		if port not in ports:
			return
		if ports[port]:
			# Close serial port, in case it still exists.
			cls.disable (port)
		del ports[port]
		cls._broadcast (None, 'del_port', port)
	@classmethod
	def get_ports (cls):
		return [(p, ports[p].printer.name if ports[p] else None) for p in ports]
	@classmethod
	def set_default_printer (cls, name = None, port = None):
		global default_printer
		default_printer = (name, port)
	@classmethod
	def get_default_printer (cls):
		return default_printer
	@classmethod
	def set_blacklist (cls, newlist):
		global blacklist
		blacklist = newlist
		cls._broadcast (None, 'blacklist', blacklist)
	@classmethod
	def get_blacklist (cls):
		return blacklist
	@classmethod
	def new_script (cls, code):
		global nextscriptname
		name = '%04d' % nextscriptname
		scripts[name] = [code, None]
		while '%04d' % nextscriptname in scripts:
			nextscriptname += 1
		with open (xdgbasedir.data_filename_write (os.path.join ('scripts', name + os.extsep + 'js'), packagename = 'printer3d'), 'wb') as f:
			f.write (code)
		cls._broadcast (None, 'new_script', name, code, None)
		return []
	@classmethod
	def del_script (cls, name):
		del scripts[name]
		for e in ('js', 'dat'):
			filename = xdgbasedir.data_filename_write (os.path.join ('scripts', name + os.extsep + e), packagename = 'printer3d')
			if os.path.exists (filename):
				os.unlink (filename)
		cls._broadcast (None, 'del_script', name)
	@classmethod
	def set_data (cls, name, data):
		scripts[name][1] = data
		filename = xdgbasedir.data_filename_write (os.path.join ('scripts', name + os.extsep + 'dat'), packagename = 'printer3d')
		if data is None:
			if os.path.exists (filename):
				os.unlink (filename)
		else:
			with open (filename, 'wb') as f:
				f.write (data)
		cls._broadcast (None, 'new_data', name, data)
	@classmethod
	def queue_add (cls, data, name):
		assert name not in queue
		parsed = gcode_parse (data)
		queue[name] = (parsed, gcode_bbox (parsed))
		cls._broadcast (None, 'queue', [(q, queue[q][1]) for q in queue])
		return ''
	@classmethod
	def queue_remove (cls, name):
		assert name in queue
		del queue[name]
		cls._broadcast (None, 'queue', [(q, queue[q][1]) for q in queue])
	def set_printer (self, printer = None, port = None):
		self.printer = self.find_printer (printer, port)
	def get_printer (self):
		return self.printer.printer.name if self.printer is not None else None
	def import_settings (self, settings, filename = None):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		section = 'general'
		index = None
		regexp = re.compile ('\s*\[(general|(axis|axis_motor|extruder|extruder_motor|extruder_temp|temp|gpio)\s+(\d+))\]\s*$|\s*(\w+)\s*=\s*(.*?)\s*$|\s*(?:#.*)?$')
		errors = []
		for l in settings.split ('\n'):
			r = regexp.match (l)
			if not r:
				errors.append ((l, 'syntax error'))
				continue
			if r.group (1):
				# New section.
				if r.group (3):
					section = r.group (2)
					index = int (r.group (3))
				else:
					section = r.group (1)
					index = None
				continue
			if not r.group (4):
				# Comment.
				continue
			key = r.group (4)
			value = r.group (5)
			if key != 'name':
				if key.endswith ('limit') or key.endswith ('pin') or key.startswith ('num'):
					value = int (value)
				else:
					value = float (value)
			try:
				if section == 'general':
					c = websockets.call (resumeinfo, getattr (self.printer.printer, 'set_' + key), value)
					while c (): c.args = (yield websockets.WAIT)
				else:
					c = websockets.call (resumeinfo, getattr (self.printer.printer, section + '_set_' + key), index, value)
					while c (): c.args = (yield websockets.WAIT)
			except:
				errors.append ((l, str (sys.exc_value)))
		yield errors
	def gcode (self, code, filename = None):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		c = websockets.call (resumeinfo, self.printer.gcode, code)
		while c (): c.args = (yield websockets.WAIT)
		yield ''
	def gcode_parse (self, code):
		resumeinfo = [(yield), None]
		c = websockets.call (resumeinfo, gcode_parse, code)
		while c (): c.args = (yield websockets.WAIT)
		yield c.ret ()
	def gcode_bbox (self, code):
		resumeinfo = [(yield), None]
		c = websockets.call (resumeinfo, gcode_bbox, code)
		while c (): c.args = (yield websockets.WAIT)
		yield c.ret ()
	def gcode_run (self, code, ref = (0, 0), angle = 0):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		c = websockets.call (resumeinfo, self.printer.gcode_run, code, ref, angle)
		while c (): c.args = (yield websockets.WAIT)
		yield c.ret ()
	def wait_for_signal (self, name):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		if name not in self.printer.signals:
			self.printer.signals[name] = []
		try:
			self.printer.signals[name].append (resumeinfo[0])
			ret = (yield websockets.WAIT)
		finally:
			self.remove_waiter (name, resumeinfo[0])
		yield ret
	def remove_waiter (self, name, target):
		self.printer.signals[name].remove (target)
		if len (self.printer.signals[name]) == 0:
			del self.printer.signals[name]
	def trigger (self, name, arg = None):
		if name in self.printer.signals:
			for target in self.printer.signals[name][:]:
				target (arg)
		Connection._broadcast (None, 'signal', self.printer.printer.port, name, arg)
	def home (self):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		c = websockets.call (resumeinfo, self.printer.home)
		while c (): c.args = (yield websockets.WAIT)
	def home_z (self):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		c = websockets.call (resumeinfo, self.printer.home, [2])
		while c (): c.args = (yield websockets.WAIT)
	def goto (self, *a, **ka):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		if len (self.printer._gcode) > 0:
			print_done (self.printer.printer.port, False, 'aborted by goto command')
		c = websockets.call (resumeinfo, self.printer.printer.goto, *a, **ka)
		while c (): c.args = (yield websockets.WAIT)
	def sleep_all (self):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		if len (self.printer._gcode) > 0:
			print_done (self.printer.printer.port, False, 'aborted by sleep command')
		for a in range (self.printer.printer.get_num_axes ()):
			c = websockets.call (resumeinfo, self.printer.printer.sleep_axis, a)
			while c (): c.args = (yield websockets.WAIT)
		for e in range (self.printer.printer.get_num_extruders ()):
			c = websockets.call (resumeinfo, self.printer.printer.sleep_extruder, e)
			while c (): c.args = (yield websockets.WAIT)
	def status (self):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		c = websockets.call (resumeinfo, self.printer.printer.readtemp_temp, 0)
		while c (): c.args = (yield websockets.WAIT)
		t = c.ret ()
		c = websockets.call (resumeinfo, self.printer.printer.readtemp_extruder, 0)
		while c (): c.args = (yield websockets.WAIT)
		yield (t, c.ret ())
	def set_monitor (self, value):
		self.socket.monitor = value
		if self.socket.monitor:
			self.socket.autodetect.event (autodetect)
			self.socket.blacklist.event (blacklist)
			for p in ports:
				self.socket.new_port.event (p)
				if ports[p]:
					Connection._send_printer (self.socket, ports[p].printer)
			for s in scripts:
				Connection._broadcast (self.socket, 'new_script', s, scripts[s][0], scripts[s][1])
			Connection._broadcast (self.socket, 'queue', [(q, queue[q][1]) for q in queue])
	def get_monitor (self):
		return self.socket.monitor
	def request_confirmation (self, message):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		c = websockets.call (resumeinfo, self.printer.request_confirmation, message)
		while c (): c.args = (yield websockets.WAIT)
		yield c.ret ()
	def confirm (self, success = True):
		assert self.printer is not None
		self.printer.confirm (success)
	def queue_print (self, names, ref = (0, 0), angle = 0):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		for n in names:
			c = websockets.call (resumeinfo, self.printer.gcode_run, queue[n][0], ref, angle)
			while c (): c.args = (yield websockets.WAIT)
			if c.ret ():
				yield c.ret ()
	def __getattr__ (self, attr):
		#log ('other: %s' % attr)
		assert self.printer is not None
		return getattr (self.printer.printer, attr)
# }}}

def print_done (port, completed, reason):
	ports[port]._gcode = []
	Connection._broadcast (None, 'printing', port, False)
	if config['done']:
		cmd = config['done']
		if '[[STATE]]' in cmd:
			cmd = cmd.replace ('[[STATE]]', 'completed' if completed else 'aborted')
		if '[[REASON]]' in cmd:
			cmd = cmd.replace ('[[REASON]]', reason)
		p = subprocess.Popen (cmd, stdout = subprocess.PIPE, shell = True)
		def process_done (fd, cond):
			data = p.stdout.read ()
			if data:
				return True
			p.wait ()
			return False
		glib.io_add_watch (p.stdout.fileno (), glib.IO_IN, process_done)

httpd = None
default_printer = (None, None)
ports = {}
autodetect = config['autodetect'].lower () == 'true'
blacklist = config['blacklist']
orphans = {}
scripts = {}
queue = {}

last_id = random.randrange (1 << 32)
# Parity table is [0x8b, 0x2d, 0x1e]; half of these codes overlap with codes from the single command map; those single commands are not used.
id_map = [0x40, 0xe1, 0xd2, 0x73, 0x74, 0xd5, 0xe6, 0x47, 0xf8, 0x59, 0x6a, 0xcb, 0xcc, 0x6d, 0x5e, 0xff]
def nextid ():
	global last_id
	# 0x23456789 is an arbitrary number with bits set in every nybble, that
	# is odd (so it doesn't visit the same number twice until it did all of
	# them, because it loops at 2**32, which is not divisible by anything
	# except 2).
	last_id = (last_id + 0x23456789) & 0xffffffff
	return ''.join ([chr (id_map[(last_id >> (4 * c)) & 0xf]) for c in range (8)])
if autodetect:
	# Assume a GNU/Linux system; if you have something else, you need to come up with a way to iterate over all your serial ports and implement it here.  Patches welcome, especially if they are platform-independent.
	if os.path.exists ('/sys/class/tty'):
		for tty in os.listdir ('/sys/class/tty'):
			websockets.call (None, Connection.add_port, '/dev/' + tty) ()

if ' ' in config['printer']:
	default_printer = config['printer'].rsplit (' ', 1)
else:
	default_printer = (config['printer'], None)

for d in xdgbasedir.data_files_read ('scripts', packagename = 'printer3d'):
	for s in os.listdir (d):
		name, ext = os.path.splitext (s)
		if ext != os.extsep + 'js' or name in scripts:
			continue
		dataname = os.path.join (d, name + os.extsep + 'dat')
		scripts[name] = [open (os.path.join (d, s)).read (), open (dataname).read () if os.path.exists (dataname) else None]
nextscriptname = 0
while '%04d' % nextscriptname in scripts:
	nextscriptname += 1

class Server (websockets.RPChttpd):
	def auth_message (self, connection, is_websocket):
		return 'Please identify yourself' if config['passwordfile'] or config['login'] else None
	def authenticate (self, connection):
		if config['login']:
			if ':' in config['login']:
				user, password = config['login'].split (':', 1)
				if user == connection.data['user'] and password == connection.data['password']:
					return True
			else:
				if user == config['login']:
					return True
		if config['passwordfile']:
			with open (config['passwordfile']) as f:
				for l in f.xreadlines ():
					if ':' not in l:
						continue
					user, password = l.split (':')[:2]
					if user == connection.data['user'] and (password[1:] == connection.data['password'] if password.startswith (':') else password == crypt.crypt (connection.data['password'], password)):
						return True
		return False
	def _motor (self, name, obj, index):
		return '[%s %d]\r\n' % (name, index) + ''.join (['%s = %d\r\n' % (x, getattr (obj, x)) for x in ('step_pin', 'dir_pin', 'enable_pin')]) + ''.join (['%s = %f\r\n' % (x, getattr (obj, x)) for x in ('steps_per_mm', 'max_v_neg', 'max_v_pos', 'max_a')])
	def _temp (self, name, obj, index):
		return '[%s %d]\r\n' % (name, index) + ''.join (['%s = %d\r\n' % (x, getattr (obj, x)) for x in ('power_pin', 'thermistor_pin')]) + ''.join (['%s = %f\r\n' % (x, getattr (obj, x)) for x in ('R0', 'R1', 'Rc', 'Tc', 'beta', 'core_C', 'shell_C', 'transfer', 'radiation', 'power')])
	def page (self, connection):
		if 'port' in connection.query:
			port = connection.query['port'][0]
			if port not in ports or not ports[port]:
				self.reply (connection, 404)
			else:
				p = ports[port].printer
				message = '[general]\r\n'
				message += 'name=' + p.name.replace ('\\', '\\\\').replace ('\n', '\\n') + '\r\n'
				message += ''.join (['%s = %d\r\n' % (x, getattr (p, x)) for x in ('num_axes', 'num_extruders', 'num_temps', 'printer_type', 'led_pin', 'motor_limit', 'temp_limit')])
				message += ''.join (['%s = %d\r\n' % (x, getattr (p, x)) for x in ('room_T', 'feedrate')])
				for a in range (p.maxaxes):
					message += '[axis %d]\r\n' % a
					message += ''.join (['%s = %d\r\n' % (x, getattr (p.axis[a], x)) for x in ('limit_min_pin', 'limit_max_pin', 'sense_pin')]) + ''.join (['%s = %f\r\n' % (x, getattr (p.axis[a], x)) for x in ('limit_min_pos', 'limit_max_pos', 'delta_length', 'delta_radius', 'offset')])
					message += self._motor ('axis_motor', p.axis[a].motor, a)
				for e in range (p.maxextruders):
					message += '[extruder %d]\r\n' % e
					message += ''.join (['%s = %f\r\n' % (x, getattr (p.extruder[e], x)) for x in ('filament_heat', 'nozzle_size', 'filament_size')])
					message += self._motor ('extruder_motor', p.extruder[e].motor, e)
					message += self._temp ('extruder_temp', p.extruder[e].temp, e)
				for t in range (p.maxtemps):
					message += self._temp ('temp', p.temp[t], t)
				for g in range (p.maxgpios):
					message += '[gpio %d]\r\n' % g
					message += ''.join (['%s = %d\r\n' % (x, getattr (p.gpio[g], x)) for x in ('pin', 'state', 'master')])
					message += ''.join (['%s = %f\r\n' % (x, getattr (p.gpio[g], x)) for x in ('value',)])
				self.reply (connection, 200, message, 'text/plain;charset=utf8')
		else:
			websockets.RPChttpd.page (self, connection)

httpd = Server (config['port'], Connection, httpdirs = xdgbasedir.data_files_read ('html', packagename = 'printer3d'), address = config['address'])

log ('running')
websockets.fgloop ()
