#!/usr/bin/python
# vim: foldmethod=marker :

# Imports. {{{
import re
import os
import sys
import random
import json
import printer3d
import websockets
import xdgbasedir
import glib
import subprocess
import crypt
import time
from websockets import log
import traceback
# }}}

config = xdgbasedir.config_load (packagename = 'printer3d', defaults = {'port': 8080, 'printer': '', 'audiodir': xdgbasedir.cache_filename_write (packagename = 'printer3d', filename = 'audio', makedirs = False), 'blacklist': r'/dev/(ptmx$|console$|ttyS?\d*)$', 'autodetect': True, 'tls': None, 'avrdude': '/usr/bin/avrdude', 'login': '', 'passwordfile': '', 'done': ''})

class Printer:	# {{{
	def _init (self, port, broadcast, death):
		resumeinfo = [(yield), None]
		self.printer = printer3d.Printer ()
		# Provide easy access to some useful data.
		self.printer.id_map = ''.join ([chr (x) for x in id_map])
		self.printer.audiodir = config['audiodir']
		# Initialize the printer.
		c = websockets.call (resumeinfo, self.printer._init, port, broadcast, death, orphans, nextid ())
		while c (): c.args = (yield websockets.WAIT)
		printer = c.ret ()
		if printer is not None:
			# An orphan has reconnected.
			ports[port] = printer
			orphans.pop (printer.printer.printerid)
			c = websockets.call (resumeinfo, printer.printer._reconnect, port, self.printer.printer)
			while c (): c.args = (yield websockets.WAIT)
			yield True
		# [axes, extruders, feedrate]
		self.pos = [[0.] * self.printer.get_num_axes (), [0.] * self.printer.get_num_extruders (), float ('inf')]
		self.current_extruder = 0
		self.rel = False
		self.erel = None
		self.etemp = float ('nan')
		self.btemp = float ('nan')
		self.gcode = []
	def home (self, axes = None, keep_gcode = False):
		resumeinfo = [(yield), None]
		if not keep_gcode:
			if len (self.gcode) > 0:
				print_done (self.printer.port, False, 'aborted by home command')
			self.gcode = []
		if axes is None:
			axes = range (self.printer.get_num_axes ())
		c = websockets.call (resumeinfo, self.printer.home, axes)
		while c (): c.args = (yield websockets.WAIT)
		ret = c.ret ()
		for i, a in enumerate (axes):
			c = websockets.call (resumeinfo, self.printer.axis_get_current_pos, a)
			while c (): c.args = (yield websockets.WAIT)
			self.pos[0][a] = c.ret ()[1]
	def flush (self):
		resumeinfo = [(yield), None]
		c = websockets.call (resumeinfo, self.printer.goto, cb = True)
		while c (): c.args = (yield websockets.WAIT)
		c = websockets.call (resumeinfo, self.printer.wait_for_cb, )
		while c (): c.args = (yield websockets.WAIT)
	def parse_gcode (self, code):
		resumeinfo = [(yield), None]
		if len (self.gcode) > 0:
			print_done (self.printer.port, False, 'aborted by starting new print')
		self.gcode = []
		for lineno, line in enumerate (code.split ('\n')):
			line = line.strip ()
			if line.startswith ('N'):
				r = re.match ('N\d+\s*(.*?)\*\d+$')
				if not r:
					# Invalid line; ignore it.
					log ('%d:ignoring invalid gcode: %s' % (lineno, line))
					continue
				line = r.group (1)
			if ';' in line:
				line = line[:line.index (';')].strip ()
			if line == '':
				continue
			line = line.split ()
			cmd = line[0][0], int (line[0][1:])
			args = {}
			for a in line[1:]:
				try:
					args[a[0]] = float (a[1:])
				except:
					log ('%d:ignoring invalid gcode: %s' % (lineno, line))
					break
			else:
				self.gcode.append ((cmd, args))
		if len (self.gcode) > 0:
			Connection._broadcast (None, 'printing', self.printer.port, True)
		c = websockets.call (resumeinfo, self.send_gcode)
		while c (): c.args = (yield websockets.WAIT)
	def send_gcode (self):
		resumeinfo = [(yield), None]
		if len (self.gcode) == 0:
			yield False
		while len (self.gcode) > 0:
			c = websockets.call (resumeinfo, self.parse_gcode_chunk, *self.gcode.pop (0))
			while c (): c.args = (yield websockets.WAIT)
		print_done (self.printer.port, True, 'completed')
		yield False
	def parse_gcode_chunk (self, cmd, args):
		resumeinfo = [(yield), None]
		global etemp, btemp, rel, erel
		#log ('Parsing %s %s' % (cmd, args))
		if cmd[0] == 'T':
			# Tool selection.
			target = cmd[1]
			assert len (self.pos[1]) > target
			self.current_extruder = target
		elif cmd[0] == 'G' and cmd[1] in (0, 1):
			components = {'X': None, 'Y': None, 'Z': None, 'E': None, 'F': None}
			for c in args:
				assert c in components and components[c] is None
				components[c] = args[c]
			f0 = self.pos[2]
			if components['F'] is not None:
				self.pos[2] = components['F']
			if components['E'] is not None:
				if self.erel or (self.erel is None and self.rel):
					estep = components['E']
				else:
					estep = components['E'] - self.pos[1][self.current_extruder]
				self.pos[1][self.current_extruder] += estep
			else:
				estep = 0
			oldpos = self.pos[0][:]
			for axis in range (3):
				value = components[chr (ord ('X') + axis)]
				if value is not None:
					if self.rel:
						self.pos[0][axis] += value
					else:
						self.pos[0][axis] = value
			dist = sum ([(self.pos[0][x] - oldpos[x]) ** 2 for x in range (3)]) ** .5
			if dist == 0:
				dist = abs (estep)
			#log ('going to %s estep %s f0 %s dist %s' % (self.pos, estep, f0, dist))
			if dist > 0:
				#if f0 is None:
				#	f0 = self.pos[1][self.current_extruder]
				f0 = self.pos[2]	# Use new value.
				if f0 == 0:
					f0 = float ('inf')
				c = websockets.call (resumeinfo, self.printer.goto, axes = {0: self.pos[0][0], 1: self.pos[0][1], 2: self.pos[0][2]}, e = estep, f0 = f0 / dist / 60, f1 = self.pos[2] / dist / 60, cb = False)
				while c (): c.args = (yield websockets.WAIT)
				#self.printer.wait_for_cb ()
		elif cmd == ('G', 28):
			c = websockets.call (resumeinfo, self.flush)
			while c (): c.args = (yield websockets.WAIT)
			which = ''
			for w in args:
				which += w
			if which == '':
				which = 'XYZ'
			axes = [ord (w) - ord ('X') for w in which]
			c = websockets.call (resumeinfo, self.home, axes, True)
			while c (): c.args = (yield websockets.WAIT)
		elif cmd == ('G', 4):
			c = websockets.call (resumeinfo, self.flush)
			while c (): c.args = (yield websockets.WAIT)
			if 'P' in args:
				time.sleep (args['P'] / 1000) # TODO
		elif cmd == ('G', 21):
			pass
		elif cmd == ('G', 90):
			self.rel = False
		elif cmd == ('G', 91):
			self.rel = True
		elif cmd == ('G', 92):
			which = {}
			for w in args:
				if w in 'XYZ':
					wh = ord (w) - ord ('X')
					self.pos[0][wh] = args[w]
					which[wh] = args[w]
				elif w == 'E':
					self.pos[1][self.current_extruder] = args[w]
			if len (which) > 0:
				c = websockets.call (resumeinfo, self.flush)
				while c (): c.args = (yield websockets.WAIT)
				for w in which:
					c = websockets.call (resumeinfo, self.printer.axis_set_current_pos, w, which[w])
					while c (): c.args = (yield websockets.WAIT)
		elif cmd == ('M', 42):
			pin = args['P']
			value = args['S']
			c = websockets.call (resumeinfo, self.printer.settemp_temp, pin, value)
			while c (): c.args = (yield websockets.WAIT)
		elif cmd == ('M', 82):
			self.erel = False
		elif cmd == ('M', 83):
			self.erel = True
		elif cmd == ('M', 84):
			c = websockets.call (resumeinfo, self.flush)
			while c (): c.args = (yield websockets.WAIT)
			for axis in range (3):
				c = websockets.call (resumeinfo, self.printer.sleep_axis, axis)
				while c (): c.args = (yield websockets.WAIT)
			c = websockets.call (resumeinfo, self.printer.sleep_extruder, 0)
			while c (): c.args = (yield websockets.WAIT)
		elif cmd == ('M', 104):
			c = websockets.call (resumeinfo, self.flush)
			while c (): c.args = (yield websockets.WAIT)
			self.etemp = args['S']
			c = websockets.call (resumeinfo, self.printer.settemp_extruder, 0, self.etemp)
			while c (): c.args = (yield websockets.WAIT)
		elif cmd == ('M', 106):	# Fan on
			#c = websockets.call (resumeinfo, self.flush)
			#while c (): c.args = (yield websockets.WAIT)
			#c = websockets.call (resumeinfo, self.printer.settemp_temp, 1, float ('inf'))
			#while c (): c.args = (yield websockets.WAIT)
			pass
		elif cmd == ('M', 107):
			#c = websockets.call (resumeinfo, self.flush)
			#while c (): c.args = (yield websockets.WAIT)
			#c = websockets.call (resumeinfo, self.printer.settemp_temp, 1, float ('nan'))
			#while c (): c.args = (yield websockets.WAIT)
			pass
		elif cmd == ('M', 109):
			c = websockets.call (resumeinfo, self.flush)
			while c (): c.args = (yield websockets.WAIT)
			self.etemp = args['S']
			c = websockets.call (resumeinfo, self.printer.settemp_extruder, 0, self.etemp)
			while c (): c.args = (yield websockets.WAIT)
			if self.printer.pin_valid (self.printer.extruder_temp_get_thermistor_pin (0)):
				c = websockets.call (resumeinfo, self.printer.waittemp_extruder, 0, self.etemp, float ('nan'))
				while c (): c.args = (yield websockets.WAIT)
		elif cmd == ('M', 116):
			c = websockets.call (resumeinfo, self.flush)
			while c (): c.args = (yield websockets.WAIT)
			if self.printer.pin_valid (self.printer.extruder_temp_get_thermistor_pin (0)):
				c = websockets.call (resumeinfo, self.printer.waittemp_extruder, 0, self.etemp, float ('nan'))
				while c (): c.args = (yield websockets.WAIT)
			if self.printer.pin_valid (self.printer.temp_get_thermistor_pin (0)):
				c = websockets.call (resumeinfo, self.printer.waittemp_temp, 0, self.btemp, float ('nan'))
				while c (): c.args = (yield websockets.WAIT)
		elif cmd == ('M', 140):
			c = websockets.call (resumeinfo, self.flush)
			while c (): c.args = (yield websockets.WAIT)
			self.btemp = args['S']
			c = websockets.call (resumeinfo, self.printer.settemp_temp, 0, self.btemp)
			while c (): c.args = (yield websockets.WAIT)
		elif cmd == ('M', 190):
			c = websockets.call (resumeinfo, self.flush)
			while c (): c.args = (yield websockets.WAIT)
			if 'S' in args:
				self.btemp = args['S']
				c = websockets.call (resumeinfo, self.printer.settemp_temp, 0, self.btemp)
				while c (): c.args = (yield websockets.WAIT)
			if self.printer.pin_valid (self.printer.temp_get_thermistor_pin (0)):
				c = websockets.call (resumeinfo, self.printer.waittemp_temp, 0, self.btemp, float ('nan'))
				while c (): c.args = (yield websockets.WAIT)
		else:
			raise SyntaxError ('invalid gcode command %s' % cmd)
# }}}

class Connection: # {{{
	def __init__ (self, socket):
		socket.monitor = False
		self.socket = socket
		self.printer = self.find_printer (*default_printer)
	@classmethod
	def _broadcast (cls, target, name, *args):
		if target:
			if target.monitor:
				getattr (target, name).event (*args)
		elif httpd:
			for c in httpd.websockets:
				if c.monitor:
					getattr (c, name).event (*args)
	@classmethod
	def upload (cls, port, board):
		resumeinfo = [(yield), None]
		cls.disable (port)
		if board == 'melzi':
			protocol = 'arduino'
			baudrate = '115200'
			mcu = 'atmega1284p'
			filename = xdgbasedir.data_files_read (os.path.join ('firmware', 'mighty_opt.hex'), packagename = 'printer3d')[0]
		elif board == 'ramps':
			protocol = 'wiring'
			baudrate = '115200'
			mcu = 'atmega2560'
			filename = xdgbasedir.data_files_read (os.path.join ('firmware', 'mega2560.hex'), packagename = 'printer3d')[0]
		else:
			raise ValueError ('board type not supported')
		process = subprocess.Popen ([config['avrdude'], '-V', '-c', protocol, '-b', baudrate, '-p', mcu, '-P', port, '-U', 'flash:w:' + filename], stdin = subprocess.PIPE, stdout = subprocess.PIPE, stderr = subprocess.STDOUT)
		glib.io_add_watch (process.stdout, glib.IO_IN | glib.IO_PRI | glib.IO_HUP, lambda fd, cond: cls._upload_output (process.stdout, resumeinfo))
		yield websockets.WAIT
		if autodetect:
			c = websockets.call (resumeinfo, cls.detect, port)
			while c (): c.args = (yield websockets.WAIT)
		yield process.wait ()
	@classmethod
	def _upload_output (cls, pipe, resumeinfo):
		data = pipe.read ()
		if data != '':
			return True
		resumeinfo[0] ()
		return False
	@classmethod
	def find_printer (cls, name = None, port = None):
		for p in ports:
			if not ports[p]:
				continue
			if (name is None or re.match (name, ports[p].printer.name)) and (port is None or re.match (port, p)):
				return ports[p]
		return None
	@classmethod
	def set_autodetect (cls, detect):
		global autodetect
		autodetect = detect
		cls._broadcast (None, 'autodetect', autodetect)
	@classmethod
	def get_autodetect (cls):
		return autodetect
	@classmethod
	def disable (cls, port):
		if port not in ports or not ports[port]:
			log ('port is not enabled')
			return
		# Close the serial connection.
		ports[port].printer._close ()
		# Forget the printer.
		ports[port] = None
		cls._broadcast (None, 'del_printer', port)
	@classmethod
	def detect (cls, port):
		resumeinfo = [(yield), None]
		log ('detecting printer on %s' % port)
		if port not in ports or ports[port] != None:
			log ('port is not in detectable state')
			return
		try:
			ports[port] = False
			p = Printer ()
			def death (port):
				if ports[port] is False:
					# Printer was still being set up; just ignore it.
					ports[port] = None
				else:
					orphans[ports[port].printer.printerid] = ports[port]
					cls.disable (port)
				if autodetect:
					websockets.call (None, cls.detect, port) ()
			c = websockets.call (resumeinfo, p._init, port, cls._broadcast, death)
			while c (): c.args = (yield websockets.WAIT)
			if c.ret ():
				# This was a orphan, which has now been adopted.
				return
			ports[port] = p
			log ('detected printer %s on %s' % (p.printer.name, port))
			cls._send_printer (None, p.printer)
		except:
			log ('no printer found on port %s' % port)
			ports[port] = None
			traceback.print_exc ()
			return
	@classmethod
	def _send_printer (cls, target, printer):
		cls._broadcast (target, 'new_printer', printer.port, [printer.namelen, printer.maxaxes, printer.maxextruders, printer.maxtemps, printer.audio_fragments, printer.audio_fragment_size, printer.num_digital_pins, printer.num_pins])
		printer._variables_update (target)
		for a in range (printer.maxaxes):
			printer._axis_update (a, target)
		for e in range (printer.maxextruders):
			printer._extruder_update (e, target)
		for t in range (printer.maxtemps):
			printer._temp_update (t, target)
		if len (ports[printer.port].gcode) > 0:
			cls._broadcast (target, 'printing', printer.port, True)
	@classmethod
	def detect_all (cls):
		resumeinfo = [(yield), None]
		for p in ports:
			if ports[p] is not None:
				continue
			c = websockets.call (resumeinfo, cls.detect, p)
			while c (): c.args = (yield websockets.WAIT)
	@classmethod
	def add_port (cls, port):
		resumeinfo = [(yield), None]
		if port in ports:
			log ('already existing port %s cannot be added' % port)
			return
		if re.match (blacklist, port):
			#log ('skipping blacklisted port %s' % port)
			return
		ports[port] = None
		cls._broadcast (None, 'new_port', port);
		if autodetect:
			c = websockets.call (resumeinfo, cls.detect, port)
			while c (): c.args = (yield websockets.WAIT)
	@classmethod
	def remove_port (cls, port):
		print ('removing port %s' % port)
		if port not in ports:
			return
		if ports[port]:
			# Close serial port, in case it still exists.
			cls.disable (port)
			#orphans.append (ports[port])
		del ports[port]
		cls._broadcast (None, 'del_port', port)
	@classmethod
	def get_ports (cls):
		return [(p, ports[p].printer.name if ports[p] else None) for p in ports]
	@classmethod
	def set_default_printer (cls, name = None, port = None):
		global default_printer
		default_printer = (name, port)
	@classmethod
	def get_default_printer (cls):
		return default_printer
	@classmethod
	def set_blacklist (cls, newlist):
		global blacklist
		blacklist = newlist
		cls._broadcast (None, 'blacklist', blacklist)
	@classmethod
	def get_blacklist (cls):
		return blacklist
	def set_printer (self, printer = None, port = None):
		self.printer = self.find_printer (printer, port)
	def get_printer (self):
		return self.printer.printer.name if self.printer is not None else None
	def gcode (self, code):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		c = websockets.call (resumeinfo, self.printer.parse_gcode, code)
		while c (): c.args = (yield websockets.WAIT)
	def home_all (self):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		c = websockets.call (resumeinfo, self.printer.home)
		while c (): c.args = (yield websockets.WAIT)
	def home_z (self):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		c = websockets.call (resumeinfo, self.printer.home, [2])
		while c (): c.args = (yield websockets.WAIT)
	def sleep_all (self):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		if len (self.printer.gcode) > 0:
			print_done (self.printer.printer.port, False, 'aborted by sleep command')
		self.printer.gcode = []
		for a in range (self.printer.printer.get_num_axes ()):
			c = websockets.call (resumeinfo, self.printer.printer.sleep_axis, a)
			while c (): c.args = (yield websockets.WAIT)
		for e in range (self.printer.printer.get_num_extruders ()):
			c = websockets.call (resumeinfo, self.printer.printer.sleep_extruder, e)
			while c (): c.args = (yield websockets.WAIT)
	def status (self):
		resumeinfo = [(yield), None]
		assert self.printer is not None
		c = websockets.call (resumeinfo, self.printer.printer.readtemp_temp, 0)
		while c (): c.args = (yield websockets.WAIT)
		t = c.ret ()
		c = websockets.call (resumeinfo, self.printer.printer.readtemp_extruder, 0)
		while c (): c.args = (yield websockets.WAIT)
		yield (t, c.ret ())
	def set_monitor (self, value):
		self.socket.monitor = value
		if self.socket.monitor:
			self.socket.autodetect.event (autodetect)
			self.socket.blacklist.event (blacklist)
			for p in ports:
				self.socket.new_port.event (p)
				if ports[p]:
					Connection._send_printer (self.socket, ports[p].printer)
	def get_monitor (self):
		return self.socket.monitor
	def __getattr__ (self, attr):
		#log ('other: %s' % attr)
		assert self.printer is not None
		return getattr (self.printer.printer, attr)
# }}}

def print_done (port, completed, reason):
	Connection._broadcast (None, 'printing', self.printer.port, False)
	if config['done']:
		cmd = config['done']
		if '[[STATE]]' in cmd:
			cmd = cmd.replace ('[[STATE]]', 'completed' if completed else 'aborted')
		if '[[REASON]]' in cmd:
			cmd = cmd.replace ('[[REASON]]', reason)
		p = subprocess.Popen (cmd, stdout = subprocess.PIPE, shell = True)
		def process_done (fd, cond):
			data = p.stdout.read ()
			if data:
				return True
			p.wait ()
			return False
		glib.io_add_watch (p.stdout.fileno (), glib.IO_IN, process_done)

httpd = None
default_printer = (None, None)
ports = {}
autodetect = config['autodetect']
blacklist = config['blacklist']
orphans = {}

last_id = random.randrange (1 << 32)
# Parity table is [0x8b, 0x2d, 0x1e]; half of these codes overlap with codes from the single command map; those single commands are not used.
id_map = [0x40, 0xe1, 0xd2, 0x73, 0x74, 0xd5, 0xe6, 0x47, 0xf8, 0x59, 0x6a, 0xcb, 0xcc, 0x6d, 0x5e, 0xff]
def nextid ():
	global last_id
	# 0x23456789 is an arbitrary number with bits set in every nybble, that
	# is odd (so it doesn't visit the same number twice until it did all of
	# them, because it loops at 2**32, which is not divisible by anything
	# except 2).
	last_id = (last_id + 0x23456789) & 0xffffffff
	return ''.join ([chr (id_map[(last_id >> (4 * c)) & 0xf]) for c in range (8)])
if autodetect:
	# Assume a GNU/Linux system; if you have something else, you need to come up with a way to iterate over all your serial ports and implement it here.  Patches welcome, especially if they are platform-independent.
	if os.path.exists ('/sys/class/tty'):
		for tty in os.listdir ('/sys/class/tty'):
			websockets.call (None, Connection.add_port, '/dev/' + tty) ()

if ' ' in config['printer']:
	default_printer = config['printer'].rsplit (' ', 1)
else:
	default_printer = (config['printer'], None)

class Server (websockets.RPChttpd):
	def auth_message (self, connection, is_websocket):
		return 'Please identify yourself' if config['passwordfile'] or config['login'] else None
	def authenticate (self, connection):
		if config['login']:
			if ':' in config['login']:
				user, password = config['login'].split (':', 1)
				if user == connection.data['user'] and password == connection.data['password']:
					return True
			else:
				if user == config['login']:
					return True
		if config['passwordfile']:
			with open (config['passwordfile']) as f:
				for l in f.xreadlines ():
					if ':' not in l:
						continue
					user, password = l.split (':', 1)
					if user == connection.data['user'] and (password[1:] == connection.data['password'] if password.startswith (':') else password == crypt.crypt (connection.data['password'], password)):
						return True
		return False
	def _motor (self, name, obj, index):
		return '[%s %d]\n' % (name, index) + ''.join (['%s = %d\n' % (x, getattr (obj, x)) for x in ('step_pin', 'dir_pin', 'enable_pin')]) + ''.join (['%s = %f\n' % (x, getattr (obj, x)) for x in ('steps_per_mm', 'max_v_neg', 'max_v_pos', 'max_a')])
	def _temp (self, name, obj, index):
		return '[%s %d]\n' % (name, index) + ''.join (['%s = %d\n' % (x, getattr (obj, x)) for x in ('power_pin', 'thermistor_pin')]) + ''.join (['%s = %f\n' % (x, getattr (obj, x)) for x in ('R0', 'R1', 'Rc', 'Tc', 'beta', 'core_C', 'shell_C', 'transfer', 'radiation', 'power')])
	def page (self, connection):
		if 'port' in connection.query:
			port = connection.query['port'][0]
			if port not in ports or not ports[port]:
				self.reply (connection, 404)
			else:
				p = ports[port].printer
				message = '[general]\n'
				message += 'name=' + p.name.replace ('\\', '\\\\').replace ('\n', '\\n') + '\n'
				message += ''.join (['%s = %d\n' % (x, getattr (p, x)) for x in ('num_axes', 'num_extruders', 'num_temps', 'printer_type', 'led_pin', 'motor_limit', 'temp_limit')])
				message += ''.join (['%s = %d\n' % (x, getattr (p, x)) for x in ('room_T', 'feedrate')])
				for a in range (p.maxaxes):
					message += '[axis %d]\n' % a
					message += ''.join (['%s = %d\n' % (x, getattr (p.axis[a], x)) for x in ('limit_min_pin', 'limit_max_pin', 'sense_pin')]) + ''.join (['%s = %f\n' % (x, getattr (p.axis[a], x)) for x in ('limit_min_pos', 'limit_max_pos', 'delta_length', 'delta_radius', 'offset')])
					message += self._motor ('axis_motor', p.axis[a].motor, a)
				for e in range (p.maxextruders):
					message += '[extruder %d]\n' % e
					message += ''.join (['%s = %f\n' % (x, getattr (p.extruder[e], x)) for x in ('filament_heat', 'nozzle_size', 'filament_size')])
					message += self._motor ('extruder_motor', p.extruder[e].motor, e)
					message += self._temp ('extruder_temp', p.extruder[e].temp, e)
				for t in range (p.maxtemps):
					message += self._temp ('temp', p.temp[t], t)
				self.reply (connection, 200, message, 'text/plain;charset=utf8')
		else:
			websockets.RPChttpd.page (self, connection)

httpd = Server (config['port'], Connection, httpdirs = xdgbasedir.data_files_read ('html', packagename = 'printer3d'), tls = config['tls'])

log ('running')
websockets.fgloop ()
