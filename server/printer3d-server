#!/usr/bin/python
# vim: foldmethod=marker :

# Imports. {{{
import re
import os
import sys
import json
import printer3d
import websockets
import xdgbasedir
import glib
import time
from websockets import log
import traceback
# }}}

config = xdgbasedir.config_load (packagename = 'printer3d', defaults = {'port': 8080, 'printer': '', 'audiodir': xdgbasedir.cache_filename_write (packagename = 'printer3d', filename = 'audio', makedirs = False), 'blacklist': 'ptmx$|console$|ttyS?\d*$', 'autodetect': True})

class Printer:	# {{{
	def __init__ (self, port):
		self.printer = printer3d.Printer (port)
		self.printer.continue_cb = lambda: glib.idle_add (self.send_gcode)
		self.printer.audiodir = config['audiodir']
		glib.io_add_watch (self.printer.printer.fd, glib.IO_IN, self.printer_input)
		# [axes, extruders, feedrate]
		self.pos = [[0.] * self.printer.get_num_axes (), [0.] * self.printer.get_num_extruders (), float ('inf')]
		self.current_extruder = 0
		self.rel = False
		self.erel = None
		self.etemp = float ('nan')
		self.btemp = float ('nan')
		self.gcode = []
	def home (self, axes = None):
		self.gcode = []
		if axes is None:
			axes = range (self.printer.get_num_axes ())
		ret = self.printer.home (axes)
		for i, a in enumerate (axes):
			self.pos[0][a] = self.printer.axis_get_current_pos (a)[1]
	def flush (self):
		self.printer.goto (cb = True)
		self.printer.wait_for_cb ()
	def parse_gcode (self, code):
		self.gcode = []
		for lineno, line in enumerate (code.split ('\n')):
			line = line.strip ()
			if line.startswith ('N'):
				r = re.match ('N\d+\s*(.*?)\*\d+$')
				if not r:
					# Invalid line; ignore it.
					print ('%d:ignoring invalid gcode: %s' % (lineno, line))
					continue
				line = r.group (1)
			if ';' in line:
				line = line[:line.index (';')].strip ()
			if line == '':
				continue
			line = line.split ()
			cmd = line[0][0], int (line[0][1:])
			args = {}
			for a in line[1:]:
				try:
					args[a[0]] = float (a[1:])
				except:
					print ('%d:ignoring invalid gcode: %s' % (lineno, line))
					break
			else:
				self.gcode.append ((cmd, args))
		self.send_gcode ()
	def send_gcode (self):
		if len (self.gcode) == 0:
			return False
		while len (self.gcode) > 0 and not self.printer.is_waiting ():
			self.parse_gcode_chunk (*self.gcode.pop (0))
		return False
	def printer_input (self, source, condition):
		self.printer.block (.1)
		self.send_gcode ()
		return True
	def parse_gcode_chunk (self, cmd, args):
		global etemp, btemp, rel, erel
		#print ('Parsing %s %s' % (cmd, args))
		if cmd[0] == 'T':
			# Tool selection.
			target = cmd[1]
			assert len (self.pos[1]) > target
			self.current_extruder = target
		elif cmd[0] == 'G' and cmd[1] in (0, 1):
			components = {'X': None, 'Y': None, 'Z': None, 'E': None, 'F': None}
			for c in args:
				assert c in components and components[c] is None
				components[c] = args[c]
			f0 = self.pos[2]
			if components['F'] is not None:
				self.pos[2] = components['F']
			if components['E'] is not None:
				if self.erel or (self.erel is None and self.rel):
					estep = components['E']
				else:
					estep = components['E'] - self.pos[1][self.current_extruder]
				self.pos[1][self.current_extruder] += estep
			else:
				estep = 0
			oldpos = self.pos[0][:]
			for axis in range (3):
				value = components[chr (ord ('X') + axis)]
				if value is not None:
					if self.rel:
						self.pos[0][axis] += value
					else:
						self.pos[0][axis] = value
			dist = sum ([(self.pos[0][x] - oldpos[x]) ** 2 for x in range (3)]) ** .5
			if dist == 0:
				dist = abs (estep)
			#print ('going to %s estep %s f0 %s dist %s' % (self.pos, estep, f0, dist))
			if dist > 0:
				#if f0 is None:
				#	f0 = self.pos[1][self.current_extruder]
				f0 = self.pos[2]	# Use new value.
				if f0 == 0:
					f0 = float ('inf')
				self.printer.goto (axes = {0: self.pos[0][0], 1: self.pos[0][1], 2: self.pos[0][2]}, e = estep, f0 = f0 / dist / 60, f1 = self.pos[2] / dist / 60, cb = False)
				#self.printer.wait_for_cb ()
		elif cmd == ('G', 28):
			self.flush ()
			which = ''
			for w in args:
				which += w
			if which == '':
				which = 'XYZ'
			axes = [ord (w) - ord ('X') for w in which]
			gcode = self.gcode
			self.home (axes)
			self.gcode = gcode
		elif cmd == ('G', 4):
			self.flush ()
			if 'P' in args:
				time.sleep (args['P'] / 1000)
		elif cmd == ('G', 21):
			pass
		elif cmd == ('G', 90):
			self.rel = False
		elif cmd == ('G', 91):
			self.rel = True
		elif cmd == ('G', 92):
			which = {}
			for w in args:
				if w in 'XYZ':
					wh = ord (w) - ord ('X')
					self.pos[0][wh] = args[w]
					which[wh] = args[w]
				elif w == 'E':
					self.pos[1][self.current_extruder] = args[w]
			if len (which) > 0:
				self.flush ()
				for w in which:
					self.printer.axis_set_current_pos (w, which[w])
		elif cmd == ('M', 42):
			pin = args['P']
			value = args['S']
			self.printer.settemp_temp (pin, value)
		elif cmd == ('M', 82):
			self.erel = False
		elif cmd == ('M', 83):
			self.erel = True
		elif cmd == ('M', 84):
			self.flush ()
			for axis in range (3):
				self.printer.sleep_axis (axis)
			self.printer.sleep_extruder (0)
		elif cmd == ('M', 104):
			self.flush ()
			self.etemp = args['S']
			self.printer.settemp_extruder (0, self.etemp)
		elif cmd == ('M', 106):	# Fan on
			#self.flush ()
			#self.printer.settemp_temp (1, float ('inf'))
			pass
		elif cmd == ('M', 107):
			#self.flush ()
			#self.printer.settemp_temp (1, float ('nan'))
			pass
		elif cmd == ('M', 109):
			self.flush ()
			self.etemp = args['S']
			self.printer.settemp_extruder (0, self.etemp)
			if self.printer.extruder_temp_get_thermistor_pin (0) < 255:
				self.printer.waittemp_extruder (0, self.etemp, float ('nan'))
		elif cmd == ('M', 116):
			self.flush ()
			if self.printer.extruder_temp_get_thermistor_pin (0) < 255:
				self.printer.waittemp_extruder (0, self.etemp, float ('nan'))
			if self.printer.temp_get_thermistor_pin (0) < 255:
				self.printer.waittemp_temp (0, self.btemp, float ('nan'))
		elif cmd == ('M', 140):
			self.flush ()
			self.btemp = args['S']
			self.printer.settemp_temp (0, self.btemp)
		elif cmd == ('M', 190):
			self.flush ()
			if 'S' in args:
				self.btemp = args['S']
				self.printer.settemp_temp (0, self.btemp)
			if self.printer.temp_get_thermistor_pin (0) < 255:
				self.printer.waittemp_temp (0, self.btemp, float ('nan'))
		else:
			raise SyntaxError ('invalid gcode command %s' % cmd)
# }}}

class Connection: # {{{
	def __init__ (self, socket):
		self.socket = socket
		self.printer = self.find_printer (*default_printer)
		log ('init')
	@classmethod
	def find_printer (cls, name = None, port = None):
		if port in ports:
			return ports[port]
		if name is not None:
			for printer in printers:
				if re.match (name, printers[printer].printer.name):
					return printers[printer]
		return None
	@classmethod
	def set_autodetect (cls, detect):
		global autodetect
		autodetect = detect
	@classmethod
	def detect (cls, port):
		global default_printer
		assert port in ports and ports[port] is None
		try:
			ports[port] = Printer (port)
			print ('found printer "%s" on port %s' % (ports[port].printer.name, port))
		except:
			traceback.print_exc ()
			print ('found no printer on port %s' % port)
			return
		if ports[port].printer.name not in printers:
			printers[ports[port].printer.name] = ports[port]
	@classmethod
	def detect_all (cls):
		for p in ports:
			if ports[p] is not None:
				continue
			cls.detect (p)
	@classmethod
	def add_port (cls, port):
		assert port not in ports
		ports[port] = None
		if autodetect:
			cls.detect (port)
	@classmethod
	def remove_port (cls, port):
		assert port in ports
		#if ports[port] is not None:
		#	orphans.append (ports[port])
		del ports[port]
	@classmethod
	def get_ports (cls):
		return [(p, ports[p].printer.name if ports[p] is not None else None) for p in ports]
	@classmethod
	def set_default_printer (cls, name = None, port = None):
		global default_printer
		default_printer = (name, port)
	@classmethod
	def get_default_printer (cls):
		return default_printer
	@classmethod
	def printerlist (cls):
		return printers.keys ()
	def set_printer (self, printer):
		assert printer in printers
		self.printer = printers[printer]
	def gcode (self, code):
		assert self.printer is not None
		log ('gcode')
		self.printer.parse_gcode (code)
	def home_all (self):
		assert self.printer is not None
		self.printer.gcode = []
		self.printer.home ()
	def home_z (self):
		assert self.printer is not None
		self.printer.gcode = []
		self.printer.home ([2])
	def sleep_all (self):
		assert self.printer is not None
		self.printer.gcode = []
		for a in range (self.printer.printer.get_num_axes ()):
			self.printer.printer.sleep_axis (a)
		for e in range (self.printer.printer.get_num_extruders ()):
			self.printer.printer.sleep_extruder (e)
	def status (self):
		assert self.printer is not None
		return (self.printer.printer.readtemp_temp (0), self.printer.printer.readtemp_extruder (0))
	def __getattr__ (self, attr):
		#log ('other: %s' % attr)
		assert self.printer is not None
		return getattr (self.printer.printer, attr)
# }}}

default_printer = (None, None)
printers = {}
ports = {}
autodetect = config['autodetect']
if autodetect:
	# Assume a GNU/Linux system; if you have something else, you need to come up with a way to iterate over all your serial ports and implement it here.  Patches welcome, especially if they are platform-independent.
	for tty in os.listdir ('/sys/class/tty'):
		if re.match (config['blacklist'], tty):
			continue
		Connection.add_port ('/dev/' + tty)

if config['printer'] in ports:
	default_printer = (None, config['printer'])
else:
	default_printer = (config['printer'], None)

httpd = websockets.RPChttpd (config['port'], Connection, httpdirs = xdgbasedir.data_files_read ('html', packagename = 'printer3d'))

print ('running')
websockets.fgloop ()
