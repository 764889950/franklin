#!/usr/bin/python

import sys
import json
import printer3d
import network
import wshttpd
import xdgbasedir

config = xdgbasedir.load_config (defaults = {'httpport': 8080, 'pythonport': 'reprap|RepRap printer control', 'tls': None, 'printer': '', 'wav_pre': 'wav/command.wav', 'wav_post': 'wav/rr.wav'})
printer = printer3d.Printer (config['printer'])
pos = [0., 0., 0., None, 1.]	# 3 axes, 1 extruder, 1 feedrate; it would be nicer to make this flexible; the firmware can handle it...
rel = False
erel = False
etemp = float ('nan')
btemp = float ('nan')

def home (axes):
	ret = printer.home (axes)
	for i, a in enumerate (axes):
		pos[a] = ret[i]

def flush ():
	printer.goto (cb = True)
	printer.wait_for_cb ()

def parse_gcode (gcode):
	for lineno, line in enumerate (gcode.split ('\n')):
		line = line.strip ()
		if line.startswith ('N'):
			r = re.match ('N\d+\s*(.*?)\*\d+$')
			if not r:
				# Invalid line; ignore it.
				print ('%d:ignoring invalid gcode: %s' % (lineno, line))
				continue
			line = r.group (1)
		if ';' in line:
			line = line[:line.index (';')].strip ()
		if line == '':
			continue
		line = line.split ()
		args = {}
		for a in line[1:]:
			try:
				args[a[0]] = float (a[1:])
			except:
				print ('%d:ignoring invalid gcode: %s' % (lineno, line))
				break
		else:
			#try:
			parse_gcode_chunk (line[0], args)
			#except:
			#print ('%d:ignoring gcode because of error: %s (%s)' % (lineno, sys.exc_value, line))
	flush ()


def parse_gcode_chunk (cmd, args):
	global etemp, btemp, rel, erel
	#print ('%s %s' % (cmd, args))
	if cmd[0] == 'T':
		# Tool selection is not currently supported.
		pass
	elif cmd in ('G0', 'G1'):
		components = {'X': None, 'Y': None, 'Z': None, 'E': None, 'F': None}
		for c in args:
			assert c in components and components[c] is None
			components[c] = args[c]
		f0 = pos[4]
		if components['F'] is not None:
			pos[4] = components['F']
		if components['E'] is not None:
			if erel:
				estep = components['E']
			else:
				estep = components['E'] - pos[3]
			pos[3] += estep
		else:
			estep = 0
		oldpos = pos[:3]
		for axis in range (3):
			value = components[chr (ord ('X') + axis)]
			if value is not None:
				if rel:
					pos[axis] += value
				else:
					pos[axis] = value
		dist = sum ([(pos[x] - oldpos[x]) ** 2 for x in range (3)]) ** .5
		if dist == 0:
			dist = abs (estep)
		#if f0 is None:
		f0 = pos[4]
		print ('going to %s estep %s f0 %s dist %s' % (pos, estep, f0, dist))
		if dist > 0:
			printer.goto (axes = {0: pos[0], 1: pos[1], 2: pos[2]}, e = estep, f0 = f0 / dist / 60, f1 = pos[4] / dist / 60, cb = True)
			printer.wait_for_cb ()
	elif cmd == 'G28':
		flush ()
		which = ''
		for w in args:
			which += w
		if which == '':
			which = 'XYZ'
		axes = [ord (w) - ord ('X') for w in which]
		home (axes)
	elif cmd == 'G4':
		flush ()
		if 'P' in args:
			time.sleep (args[P] / 1000)
	elif cmd == 'G21':
		pass
	elif cmd == 'G90':
		rel = False
	elif cmd == 'G91':
		rel = True
	elif cmd == 'G92':
		which = {}
		for w in args:
			if w in 'XYZ':
				wh = ord (w) - ord ('X')
				pos[wh] = args[w]
				which[wh] = args[w]
			elif w == 'E':
				pos[3] = args[w]
		if len (which) > 0:
			flush ()
			for w in which:
				printer.axis[w].set_current_pos (which[w])
	elif cmd == 'M82':
		erel = False
	elif cmd == 'M83':
		erel = True
	elif cmd == 'M84':
		flush ()
		for axis in range (3):
			printer.sleep_axis (axis)
		printer.sleep_extruder (0)
	elif cmd == 'M104':
		flush ()
		etemp = args['S']
		printer.settemp_extruder (0, etemp)
	elif cmd == 'M106':	# Fan on
		flush ()
		printer.settemp_temp (1, float ('inf'))
	elif cmd == 'M107':
		flush ()
		printer.settemp_temp (1, float ('nan'))
	elif cmd == 'M109':
		flush ()
		etemp = args['S']
		printer.settemp_extruder (0, etemp)
		printer.waittemp_extruder (0, etemp, float ('nan'))
		printer.wait_for_temp ()
	elif cmd == 'M116':
		flush ()
		printer.waittemp_extruder (0, etemp, float ('nan'))
		printer.waittemp_temp (0, btemp, float ('nan'))
		printer.wait_for_temp ()
	elif cmd == 'M140':
		flush ()
		btemp = args['S']
		printer.settemp_temp (0, etemp)
	elif cmd == 'M190':
		flush ()
		if 'S' in args:
			btemp = args['S']
			printer.settemp_temp (0, btemp)
		printer.waittemp_temp (0, btemp, float ('nan'))
		printer.wait_for_temp ()
	else:
		raise SyntaxError ('invalid gcode command %s' % cmd)

class Connection (wshttpd.Wshttpd):
	def recv (self, frame):
		try:
			(cmd, data), index = json.JSONDecoder ().raw_decode (frame)
		except:
			self.send (json.dumps (['error', 'invalid json content']))
			return
		if cmd == 'gcode' and isinstance (data, (str, unicode)):
			if (config['wav_pre']):
				printer.play (config['wav_pre'])
			parse_gcode (data)
			if (config['wav_post']):
				printer.play (config['wav_post'])
		elif cmd == 'ping':
			self.send (json.dumps (['pong', '']))
		else:
			self.send (json.dumps (['error', 'invalid command']))
			return
		self.send (json.dumps (['ok', None]))
	def page (self):
		if self.address.path == '/':
			self.reply_html (open ('html/page.html').read ())
		elif self.address.path == '/page.js':
			self.reply_js (open ('html/page.js').read ())
		elif self.address.path == '/page.css':
			self.reply_css (open ('html/page.css').read ())
		elif self.address.path == '/audio.ogg':
			self.reply (200, open ('html/audio.ogg').read (), {'Content-Type': 'audio/ogg'})
		else:
			self.reply (404)

httpd = network.Server (config['httpport'], Connection, tls = config['tls'])
direct = network.RPCServer (config['pythonport'], lambda socket: printer, tls = config['tls'])

print ('running')
network.fgloop ()
