#!/usr/bin/python

import sys
import json
import printer3d
import network
import wshttpd
import xdgbasedir

config = xdgbasedir.load_config (defaults = {'httpport': 8080, 'pythonport': 'reprap|RepRap printer control', 'tls': None, 'printer': ''})
printer = printer3d.Printer (config['printer'])
pos = [0., 0., 0., 0., 1.]	# 3 axes, 1 extruder, 1 feedrate; it would be nicer to make this flexible; the firmware can handle it...
rel = False
erel = True
etemp = float ('nan')
btemp = float ('nan')

def home (axes):
	printer.limits.clear ()
	for axis in axes:
		printer.run_axis (axis, -100 if printer.axis[axis].limit_min_pin < 255 else 100)
		pos[axis] = 0
	while len (printer.limits) < len (axes):
		printer.recv_packet (want_any = True)
	axesmove = {}
	for axis in axes:
		printer.axis[axis].set_current_pos (0)
		axesmove[axis] = 3 if printer.axis[axis].limit_min_pin < 255 else -3
	printer.goto (axes = axesmove, cb = True)
	while printer.movewait > 0:
		printer.recv_packet (want_any = True)
	printer.limits.clear ()
	for axis in axes:
		printer.run_axis (axis, -3 if printer.axis[axis].limit_min_pin < 255 else 3)
	while len (printer.limits) < len (axes):
		printer.recv_packet (want_any = True)
	for axis in axes:
		printer.axis[axis].set_current_pos (0)
	printer.goto (axes = {0: -150, 1: -150, 2: -150}, cb = True)
	while printer.movewait > 0:
		printer.recv_packet (want_any = True)
	for axis in axes:
		printer.axis[axis].set_current_pos (0)

def flush ():
	printer.goto (cb = True)
	while printer.movewait > 0:
		printer.recv_packet (want_any = True)

def parse_gcode (gcode):
	for lineno, line in enumerate (gcode.split ('\n')):
		line = line.strip ()
		if line.startswith ('N'):
			r = re.match ('N\d+\s*(.*?)\*\d+$')
			if not r:
				# Invalid line; ignore it.
				print ('%d:ignoring invalid gcode: %s' % (lineno, line))
				continue
			line = r.group (1)
		if ';' in line:
			line = line[:line.index (';')].strip ()
		if line == '':
			continue
		line = line.split ()
		args = {}
		for a in line[1:]:
			try:
				args[a[0]] = float (a[1:])
			except:
				print ('%d:ignoring invalid gcode: %s' % (lineno, line))
				break
		else:
			#try:
			parse_gcode_chunk (line[0], args)
			#except:
			#print ('%d:ignoring gcode because of error: %s (%s)' % (lineno, sys.exc_value, line))


def parse_gcode_chunk (cmd, args):
	global etemp, btemp, rel, erel
	print ('%s %s' % (cmd, args))
	if cmd in ('G0', 'G1'):
		components = {'X': None, 'Y': None, 'Z': None, 'E': None, 'F': None}
		for c in args:
			assert c in components and components[c] is None
			components[c] = args[c]
		f0 = pos[4]
		if components['F'] is not None:
			pos[4] = components['F']
		if components['E'] is not None:
			if erel:
				estep = components['E']
			else:
				estep = components['E'] - pos[3]
			pos[3] += estep
		else:
			estep = 0
		oldpos = pos[:3]
		for axis in range (3):
			value = components[chr (ord ('X') + axis)]
			if value is not None:
				if rel:
					pos[axis] += value
				else:
					pos[axis] = value
		dist = sum ([(pos[x] - oldpos[x]) ** 2 for x in range (3)]) ** .5
		if dist == 0:
			dist = 1
		print ('going to %s %s %s %s' % (pos, estep, f0, dist))
		printer.goto (axes = {0: pos[0], 1: pos[1], 2: pos[2]}, e = estep, f0 = f0 / dist, f1 = pos[4] / dist, cb = True)
		while printer.movewait > 0:
			printer.recv_packet (want_any = True)
	elif cmd == 'G28':
		which = ''
		for w in args:
			which += w
		if which == '':
			which = 'XYZ'
		axes = [ord (w) - ord ('X') for w in which]
		home (axes)
	elif cmd == 'G4':
		flush ()
		if 'P' in args:
			time.sleep (args[P] / 1000)
	elif cmd == 'G21':
		pass
	elif cmd == 'G90':
		rel = False
	elif cmd == 'G91':
		rel = True
	elif cmd == 'G92':
		which = {}
		for w in args:
			if w in 'XYZ':
				wh = ord (w) - ord ('X')
				pos[wh] = args[w]
				which[wh] = args[w]
			elif w == 'E':
				pos[3] = args[w]
		flush ()
		for w in which:
			printer.axis[w].set_current_pos (which[w])
	elif cmd == 'M82':
		erel = False
	elif cmd == 'M83':
		erel = True
	elif cmd == 'M84':
		for axis in range (3):
			printer.axis_sleep (axis)
		printer.extruder_sleep (0)
	elif cmd == 'M104':
		etemp = args['S']
		printer.settemp_extruder (0, etemp)
	elif cmd == 'M109':
		etemp = args['S']
		printer.settemp_extruder (0, etemp)
		printer.waittemp_extruder (0, etemp, float ('nan'))
		while len (printer.tempwait) > 0:
			printer.recv_packet (want_any = True)
	elif cmd == 'M116':
		printer.waittemp_extruder (0, etemp, float ('nan'))
		printer.waittemp_temp (0, btemp, float ('nan'))
		while len (printer.tempwait) > 0:
			printer.recv_packet (want_any = True)
	elif cmd == 'M140':
		btemp = args['S']
		printer.settemp_temp (0, etemp)
	elif cmd == 'M190':
		if 'S' in args:
			btemp = args['S']
			printer.settemp_temp (0, btemp)
		printer.waittemp_temp (0, btemp, float ('nan'))
		while len (printer.tempwait) > 0:
			printer.recv_packet (want_any = True)
	else:
		raise SyntaxError ('invalid line')

class Connection (wshttpd.Wshttpd):
	def recv (self, frame):
		try:
			cmd, data = json.loads (frame)
		except:
			self.send (json.dumps (['error', 'invalid json content']))
			return
		if cmd == 'gcode' and isinstance (data, (str, unicode)):
			parse_gcode (data)
		elif cmd == 'ping':
			self.send (json.dumps (['pong', '']))
		else:
			self.send (json.dumps (['error', 'invalid command']))
			return
		self.send (json.dumps (['ok', None]))
	def page (self):
		if self.address.path == '/':
			self.reply (200, open ('html/page.html').read ())
		elif self.address.path == '/page.js':
			self.reply (200, open ('html/page.js').read ().replace ('HOSTNAME', self.headers['Host']), {'Content-Type': 'application/javascript;charset=utf-8'})
		elif self.address.path == '/page.css':
			self.reply (200, open ('html/page.css').read (), {'Content-Type': 'text/css;charset=utf-8'})
		elif self.address.path == '/audio.ogg':
			self.reply (200, open ('html/audio.ogg').read (), {'Content-Type': 'audio/ogg'})
		else:
			self.reply (404)

httpd = network.Server (config['httpport'], Connection, tls = config['tls'])
direct = network.RPCServer (config['pythonport'], lambda socket: printer, tls = config['tls'])

print ('running')
network.fgloop ()
