#!/usr/bin/python

import os
import sys
import json
import printer3d
import network
import wshttpd
import xdgbasedir
import glib

config = xdgbasedir.config_load (packagename = 'printer3d', defaults = {'httpport': 8080, 'pythonport': 'reprap|RepRap printer control', 'tls': None, 'printer': '', 'wav_pre': '', 'wav_post': ''})
printer = printer3d.Printer (config['printer'])
pos = [0., 0., 0., None, 1.]	# 3 axes, 1 extruder, 1 feedrate; it would be nicer to make this flexible; the firmware can handle it...
rel = False
erel = False
etemp = float ('nan')
btemp = float ('nan')
gcode = []

def home (axes):
	ret = printer.home (axes)
	for i, a in enumerate (axes):
		pos[a] = ret[i]

def flush ():
	printer.goto (cb = True)
	printer.wait_for_cb ()

def parse_gcode (code):
	gcode[:] = []
	for lineno, line in enumerate (code.split ('\n')):
		line = line.strip ()
		if line.startswith ('N'):
			r = re.match ('N\d+\s*(.*?)\*\d+$')
			if not r:
				# Invalid line; ignore it.
				print ('%d:ignoring invalid gcode: %s' % (lineno, line))
				continue
			line = r.group (1)
		if ';' in line:
			line = line[:line.index (';')].strip ()
		if line == '':
			continue
		line = line.split ()
		args = {}
		for a in line[1:]:
			try:
				args[a[0]] = float (a[1:])
			except:
				print ('%d:ignoring invalid gcode: %s' % (lineno, line))
				break
		else:
			gcode.append ((line[0], args))
	send_gcode ()

def send_gcode ():
	if len (gcode) == 0:
		return False
	while len (gcode) > 0 and not printer.is_waiting ():
		parse_gcode_chunk (*gcode.pop (0))
	if len (gcode) == 0 and config['wav_post']:
		printer.play (config['wav_post'])
	return False

def printer_input (source, condition):
	printer.block ()
	send_gcode ()
	return True

def parse_gcode_chunk (cmd, args):
	global etemp, btemp, rel, erel
	#print ('%s %s' % (cmd, args))
	if cmd[0] == 'T':
		# Tool selection is not currently supported.
		pass
	elif cmd in ('G0', 'G1'):
		components = {'X': None, 'Y': None, 'Z': None, 'E': None, 'F': None}
		for c in args:
			assert c in components and components[c] is None
			components[c] = args[c]
		f0 = pos[4]
		if components['F'] is not None:
			pos[4] = components['F']
		if components['E'] is not None:
			if erel:
				estep = components['E']
			else:
				estep = components['E'] - pos[3]
			pos[3] += estep
		else:
			estep = 0
		oldpos = pos[:3]
		for axis in range (3):
			value = components[chr (ord ('X') + axis)]
			if value is not None:
				if rel:
					pos[axis] += value
				else:
					pos[axis] = value
		dist = sum ([(pos[x] - oldpos[x]) ** 2 for x in range (3)]) ** .5
		if dist == 0:
			dist = abs (estep)
		#if f0 is None:
		f0 = pos[4]
		#print ('going to %s estep %s f0 %s dist %s' % (pos, estep, f0, dist))
		if dist > 0:
			printer.goto (axes = {0: pos[0], 1: pos[1], 2: pos[2]}, e = estep, f0 = f0 / dist / 60, f1 = pos[4] / dist / 60, cb = False)
			#printer.wait_for_cb ()
	elif cmd == 'G28':
		flush ()
		which = ''
		for w in args:
			which += w
		if which == '':
			which = 'XYZ'
		axes = [ord (w) - ord ('X') for w in which]
		home (axes)
	elif cmd == 'G4':
		flush ()
		if 'P' in args:
			time.sleep (args[P] / 1000)
	elif cmd == 'G21':
		pass
	elif cmd == 'G90':
		rel = False
	elif cmd == 'G91':
		rel = True
	elif cmd == 'G92':
		which = {}
		for w in args:
			if w in 'XYZ':
				wh = ord (w) - ord ('X')
				pos[wh] = args[w]
				which[wh] = args[w]
			elif w == 'E':
				pos[3] = args[w]
		if len (which) > 0:
			flush ()
			for w in which:
				printer.axis_set_current_pos (w, which[w])
	elif cmd == 'M82':
		erel = False
	elif cmd == 'M83':
		erel = True
	elif cmd == 'M84':
		flush ()
		for axis in range (3):
			printer.sleep_axis (axis)
		printer.sleep_extruder (0)
	elif cmd == 'M104':
		flush ()
		etemp = args['S']
		printer.settemp_extruder (0, etemp)
	elif cmd == 'M106':	# Fan on
		flush ()
		printer.settemp_temp (1, float ('inf'))
	elif cmd == 'M107':
		flush ()
		printer.settemp_temp (1, float ('nan'))
	elif cmd == 'M109':
		flush ()
		etemp = args['S']
		printer.settemp_extruder (0, etemp)
		if printer.extruder_temp_get_thermistor_pin (0) < 255:
			printer.waittemp_extruder (0, etemp, float ('nan'))
	elif cmd == 'M116':
		flush ()
		if printer.extruder_temp_get_thermistor_pin (0) < 255:
			printer.waittemp_extruder (0, etemp, float ('nan'))
		if printer.temp_get_thermistor_pin (0) < 255:
			printer.waittemp_temp (0, btemp, float ('nan'))
	elif cmd == 'M140':
		flush ()
		btemp = args['S']
		printer.settemp_temp (0, btemp)
	elif cmd == 'M190':
		flush ()
		if 'S' in args:
			btemp = args['S']
			printer.settemp_temp (0, btemp)
		if printer.temp_get_thermistor_pin (0) < 255:
			printer.waittemp_temp (0, btemp, float ('nan'))
	else:
		raise SyntaxError ('invalid gcode command %s' % cmd)

class Connection (wshttpd.Wshttpd):
	def recv (self, frame):
		try:
			(cmd, data), index = json.JSONDecoder ().raw_decode (frame)
		except:
			self.send (json.dumps (['error', 'invalid json content']))
			return
		#print ('cmd %s data %s' % (cmd, repr (data)))
		if cmd == 'gcode' and isinstance (data, (str, unicode)):
			if (config['wav_pre']):
				printer.play (config['wav_pre'])
			parse_gcode (data)
		elif cmd == 'stop':
			printer.pause (True)
		elif cmd == 'resume':
			printer.pause (False)
		elif cmd == 'ping':
			self.send (json.dumps (['pong', '']))
		elif cmd == 'etemp':
			printer.settemp_extruder (0, float (data))
		elif cmd == 'btemp':
			printer.settemp_temp (0, float (data))
		elif cmd == 'home':
			printer.home ()
		elif cmd == 'homez':
			printer.home ([2])
		elif cmd == 'sleep':
			for a in range (printer.get_num_axes ()):
				printer.sleep_axis (a)
			for e in range (printer.get_num_extruders ()):
				printer.sleep_extruder (e)
		elif cmd == 'feed':
			printer.set_feedrate (float (data))
		elif cmd == 'status':
			self.send (json.dumps (['status', [printer.readtemp_temp (0), printer.readtemp_extruder (0)]]))
		else:
			self.send (json.dumps (['error', 'invalid command']))
			return
		self.send (json.dumps (['ok', None]))
	def page (self):
		if self.address.path == '/':
			self.reply_html (self.gethtml ('page.html'))
		elif self.address.path == '/page.js':
			self.reply_js (self.gethtml ('page.js'))
		elif self.address.path == '/page.css':
			self.reply_css (self.gethtml ('page.css'))
		elif self.address.path == '/audio.ogg':
			self.reply (200, self.gethtml ('audio.ogg'), {'Content-Type': 'audio/ogg'})
		else:
			self.reply (404)
	def gethtml (self, page):
		files = xdgbasedir.data_files_read (os.path.join ('html', page), packagename = 'printer3d')
		assert len (files) > 0
		return open (files[0]).read ()

httpd = network.Server (config['httpport'], Connection, tls = config['tls'])
direct = network.RPCServer (config['pythonport'], lambda socket: printer, tls = config['tls'])
glib.io_add_watch (printer.printer.fd, glib.IO_IN, printer_input)
printer.continue_cb = lambda: glib.idle_add (send_gcode)

print ('running')
network.fgloop ()
