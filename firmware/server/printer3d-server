#!/usr/bin/python

import os
import sys
import json
import printer3d
import wshttpd
import xdgbasedir
import glib
import time
from wshttpd import log

config = xdgbasedir.config_load (packagename = 'printer3d', defaults = {'port': 8080, 'printer': '', 'audiodir': xdgbasedir.cache_filename_write (packagename = 'printer3d', filename = 'audio', makedirs = False)})

class Printer:
	def __init__ (self, name):
		self.printer = printer3d.Printer (name)
		self.printer.continue_cb = lambda: glib.idle_add (self.send_gcode)
		self.printer.audiodir = config['audiodir']
		glib.io_add_watch (self.printer.printer.fd, glib.IO_IN, self.printer_input)
		# [axes, extruders, feedrate]
		self.pos = [[0.] * self.printer.get_num_axes (), [0.] * self.printer.get_num_extruders (), 1.]
		self.current_extruder = 0
		self.rel = False
		self.erel = False
		self.etemp = float ('nan')
		self.btemp = float ('nan')
		self.gcode = []
	def home (self, axes = None):
		if axes is None:
			axes = range (self.printer.get_num_axes ())
		ret = self.printer.home (axes)
		for i, a in enumerate (axes):
			self.pos[0][a] = ret[i]
	def flush (self):
		self.printer.goto (cb = True)
		self.printer.wait_for_cb ()
	def parse_gcode (self, code):
		self.gcode = []
		for lineno, line in enumerate (code.split ('\n')):
			line = line.strip ()
			if line.startswith ('N'):
				r = re.match ('N\d+\s*(.*?)\*\d+$')
				if not r:
					# Invalid line; ignore it.
					print ('%d:ignoring invalid gcode: %s' % (lineno, line))
					continue
				line = r.group (1)
			if ';' in line:
				line = line[:line.index (';')].strip ()
			if line == '':
				continue
			line = line.split ()
			args = {}
			for a in line[1:]:
				try:
					args[a[0]] = float (a[1:])
				except:
					print ('%d:ignoring invalid gcode: %s' % (lineno, line))
					break
			else:
				self.gcode.append ((line[0], args))
		self.send_gcode ()
	def send_gcode (self):
		if len (self.gcode) == 0:
			return False
		while len (self.gcode) > 0 and not self.printer.is_waiting ():
			self.parse_gcode_chunk (*self.gcode.pop (0))
		return False
	def printer_input (self, source, condition):
		self.printer.block ()
		self.send_gcode ()
		return True
	def parse_gcode_chunk (self, cmd, args):
		global etemp, btemp, rel, erel
		#print ('%s %s' % (cmd, args))
		if cmd[0] == 'T':
			# Tool selection.
			target = int (cmd[1:])
			assert len (self.pos[1]) > target
			self.current_extruder = target
		elif cmd in ('G0', 'G1'):
			components = {'X': None, 'Y': None, 'Z': None, 'E': None, 'F': None}
			for c in args:
				assert c in components and components[c] is None
				components[c] = args[c]
			f0 = self.pos[2]
			if components['F'] is not None:
				self.pos[2] = components['F']
			if components['E'] is not None:
				if self.erel:
					estep = components['E']
				else:
					estep = components['E'] - self.pos[1][self.current_extruder]
				self.pos[1][self.current_extruder] += estep
			else:
				estep = 0
			oldpos = self.pos[0]
			for axis in range (3):
				value = components[chr (ord ('X') + axis)]
				if value is not None:
					if self.rel:
						self.pos[0][axis] += value
					else:
						self.pos[0][axis] = value
			dist = sum ([(self.pos[0][x] - oldpos[x]) ** 2 for x in range (3)]) ** .5
			if dist == 0:
				dist = abs (estep)
			#print ('going to %s estep %s f0 %s dist %s' % (pos, estep, f0, dist))
			if dist > 0:
				#if f0 is None:
				#f0 = self.pos[1][self.current_extruder]
				f0 = self.pos[2]	# Use new value.
				self.printer.goto (axes = {0: self.pos[0][0], 1: self.pos[0][1], 2: self.pos[0][2]}, e = estep, f0 = f0 / dist / 60, f1 = self.pos[2] / dist / 60, cb = False)
				#self.printer.wait_for_cb ()
		elif cmd == 'G28':
			self.flush ()
			which = ''
			for w in args:
				which += w
			if which == '':
				which = 'XYZ'
			axes = [ord (w) - ord ('X') for w in which]
			self.home (axes)
		elif cmd == 'G4':
			self.flush ()
			if 'P' in args:
				time.sleep (args['P'] / 1000)
		elif cmd == 'G21':
			pass
		elif cmd == 'G90':
			self.rel = False
		elif cmd == 'G91':
			self.rel = True
		elif cmd == 'G92':
			which = {}
			for w in args:
				if w in 'XYZ':
					wh = ord (w) - ord ('X')
					self.pos[0][wh] = args[w]
					which[wh] = args[w]
				elif w == 'E':
					self.pos[1][self.current_extruder] = args[w]
			if len (which) > 0:
				self.flush ()
				for w in which:
					self.printer.axis_set_current_pos (w, which[w])
		elif cmd == 'M82':
			self.erel = False
		elif cmd == 'M83':
			self.erel = True
		elif cmd == 'M84':
			self.flush ()
			for axis in range (3):
				self.printer.sleep_axis (axis)
			self.printer.sleep_extruder (0)
		elif cmd == 'M104':
			self.flush ()
			self.etemp = args['S']
			self.printer.settemp_extruder (0, self.etemp)
		elif cmd == 'M106':	# Fan on
			#self.flush ()
			#self.printer.settemp_temp (1, float ('inf'))
			pass
		elif cmd == 'M107':
			#self.flush ()
			#self.printer.settemp_temp (1, float ('nan'))
			pass
		elif cmd == 'M109':
			self.flush ()
			self.etemp = args['S']
			self.printer.settemp_extruder (0, self.etemp)
			if self.printer.extruder_temp_get_thermistor_pin (0) < 255:
				self.printer.waittemp_extruder (0, self.etemp, float ('nan'))
		elif cmd == 'M116':
			self.flush ()
			if self.printer.extruder_temp_get_thermistor_pin (0) < 255:
				self.printer.waittemp_extruder (0, self.etemp, float ('nan'))
			if self.printer.temp_get_thermistor_pin (0) < 255:
				self.printer.waittemp_temp (0, self.btemp, float ('nan'))
		elif cmd == 'M140':
			self.flush ()
			self.btemp = args['S']
			self.printer.settemp_temp (0, self.btemp)
		elif cmd == 'M190':
			self.flush ()
			if 'S' in args:
				self.btemp = args['S']
				self.printer.settemp_temp (0, self.btemp)
			if self.printer.temp_get_thermistor_pin (0) < 255:
				self.printer.waittemp_temp (0, self.btemp, float ('nan'))
		else:
			raise SyntaxError ('invalid gcode command %s' % cmd)

class Connection (wshttpd.Httpd_connection):
	def __init__ (self, socket):
		self.socket = socket
		self.printer = default_printer
		log ('init')
	def set_printer (self, printer):
		assert printer in printers
		self.printer = printers[printer]
	def printerlist (self):
		return printers.keys
	def gcode (self, code):
		assert self.printer is not None
		log ('gcode')
		self.printer.parse_gcode (code)
	def home_all (self):
		assert self.printer is not None
		self.printer.gcode = []
		self.printer.home ()
	def home_z (self):
		assert self.printer is not None
		self.printer.gcode = []
		self.printer.home ([2])
	def sleep_all (self):
		assert self.printer is not None
		self.printer.gcode = []
		for a in range (self.printer.printer.get_num_axes ()):
			self.printer.printer.sleep_axis (a)
		for e in range (self.printer.printer.get_num_extruders ()):
			self.printer.printer.sleep_extruder (e)
	def status (self):
		assert self.printer is not None
		return (self.printer.printer.readtemp_temp (0), self.printer.printer.readtemp_extruder (0))
	def __getattr__ (self, attr):
		#log ('other: %s' % attr)
		assert self.printer is not None
		return getattr (self.printer.printer, attr)

default_printer = Printer (config['printer'])
printers = {default_printer.printer.get_name (): default_printer}

httpd = wshttpd.RPChttpd (config['port'], Connection, httpdirs = xdgbasedir.data_files_read ('html', packagename = 'printer3d') + ['html', '/home/shevek/src/python-wshttpd'])

print ('running')
wshttpd.fgloop ()
