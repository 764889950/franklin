#!/usr/bin/python
# vim: set foldmethod=marker :

import printer3d
import sys
import time

p = printer3d.Printer ()

def axis_test_single (axis, steps_per_s, use_min, slow, neg): # {{{
	# Move to the limit switch at slow speed.
	s = -1 if use_min else 1
	p.limits.clear ()
	# Go to the switch.
	p.run_axis (axis, s * slow / p.axis[axis].motor.steps_per_mm)
	while len (p.limits) == 0:
		p.recv_packet (want_any = True)
	p.limits.clear ()
	p.axis[axis].set_current_pos (0)
	# We're at the switch now; move away a small distance.
	distance = 3200. / p.axis[axis].motor.steps_per_mm	# Move one rotation of the motor.
	epsilon = min (distance / 4, 5)
	back = neg if use_min else not neg
	if back:
		# Move away at high speed, then almost to it at low speed; if moving away failed, we'll hit the switch.
		p.goto (axes = {axis: -s * distance}, f0 = steps_per_s / (distance * p.axis[axis].motor.steps_per_mm))
		# Try moving to the switch again (actually epsilon mm before it).
		p.goto (axes = {axis: -s * epsilon}, f0 = slow / ((distance - epsilon) * p.axis[axis].motor.steps_per_mm), cb = True)
	else:
		# Move away slowly, then fast almost to it, then slowly slightly through it; if the fast move failed, we won't hit the switch.
		p.goto (axes = {axis: -s * distance}, f0 = slow / (distance * p.axis[axis].motor.steps_per_mm))
		# Try moving to the switch again (actually epsilon mm before it).
		p.goto (axes = {axis: -s * epsilon}, f0 = steps_per_s / ((distance - epsilon) * p.axis[axis].motor.steps_per_mm))
		# And slowly through it.
		p.goto (axes = {axis: s * epsilon}, f0 = slow / (2 * epsilon * p.axis[axis].motor.steps_per_mm), cb = True)
	while p.movewait > 0:
		p.recv_packet (want_any = True)
	print p.limits
	if back:
		return axis not in p.limits
	else:
		return axis in p.limits
# }}}

def axis_test_half (axis, neg): # {{{
	# Binary search for maximum steps per second.
	assert p.axis[axis].limit_min_pin < 255 or p.axis[axis].limit_max_pin < 255
	lower = 3200. # 1 revolution per second
	upper = lower * 2
	use_min = p.axis[axis].limit_min_pin < 255
	# Find real upper bound.
	while axis_test_single (axis, upper, use_min, 3200., neg):
		lower = upper
		upper *= 2
	slow = lower / 10
	lower /= 1.5	# Just to be sure.
	upper *= 1.5	# Just to be sure.
	# Continue until we have a value within 10%.
	while upper / lower - 1. > .1:
		mid = (lower + upper) / 2
		# Try this value.
		if axis_test_single (axis, mid, use_min, 3200., neg):
			lower = (mid + lower) / 2
		else:
			upper = (mid + upper) / 2
	return upper / 4	# Be safe and set the limit well below the "missing steps"-limit.
# }}}

def test (axis): # {{{
	p.axis[axis].motor.max_f_neg = float ('inf')	# Discard old max speed.
	p.axis[axis].motor.max_f_pos = float ('inf')	# Discard old max speed.
	p.write_axis (axis)
	p.axis[axis].motor.max_f_neg = axis_test_half (axis, False)
	p.write_axis (axis)
	p.axis[axis].motor.max_f_pos = axis_test_half (axis, True)
	p.write_axis (axis)
	print ('result for axis %d: %f, %f mm/s' % (axis, p.axis[axis].motor.max_f_neg / p.axis[axis].motor.steps_per_mm, p.axis[axis].motor.max_f_pos / p.axis[axis].motor.steps_per_mm))
# }}}

def move_z_away (): # {{{
	if p.axis[2].limit_min_pin >= 255:
		return
	print p.axis[2].limit_max_pin
	# Move z out of the way.
	p.run_axis (2, -p.axis[2].motor.steps_per_mm)
	while len (p.limits) == 0:
		p.recv_packet (want_any = True)
	p.axis[2].set_current_pos (0)
	p.goto (axes = {2: 4}, f0 = 1. / 4, cb = True)
	while p.movewait != 0:
		p.recv_packet (want_any = True)
	p.sleep_axis (2)
# }}}

def calibrate_axes (): # Start easy: motors with endstops. {{{
	move_z_away ()
	for a in range (p.num_axes):
		test (a)
		p.sleep_axis (a)
		p.save_axis (a)
# }}}

def do_calibrate_temps (temps, channels): # {{{
	cold = [p.readtemp (channel) for channel in channels]
	# In steps of 10 degrees, measure how much power is required to keep the temperature there.
	temp = (int (max (cold) / 10) + 1) * 10
	while temp <= 250:
		current_channels = [x for x in channels if temp < 130 or x < 2 + p.maxaxes + p.maxextruders]
		for c in current_channels:
			p.settemp (c, temp)
		# Wait for it to stabelize
		t = time.time ()
		while time.time () < t + 10:
			p.recv_packet (want_any = True, end_time = t + 10)
		# Measure the power
		result = []
		for c in current_channels:
			p.power_start (c)
		t = time.time ()
		while time.time () < t + 10:
			p.recv_packet (want_any = True)
		for c in current_channels:
			result.append ((c, p.power_end (c)))
		print ('%d: %s' % (temp, ' '.join (['%d:%f' % x for x in result])))
		temp += 10
# }}}

def calibrate_temps (): # Then temperature sensors. {{{
	temps = []
	channels = []
	for e in range (p.maxextruders):
		if p.extruder[e].temp.thermistor_pin < 255 and p.extruder[e].temp.power_pin < 255:
			temps.append (p.extruder[e].temp)
			channels.append (2 + p.maxaxes + e)
	for t in range (p.maxtemps):
		if p.temp[t].thermistor_pin < 255 and p.temp[t].power_pin < 255:
			temps.append (p.temp[t])
			channels.append (2 + p.maxaxes + p.maxextruders + t)
	do_calibrate_temps (temps, channels)
# }}}

calibrate_axes ()
#calibrate_temps ()
