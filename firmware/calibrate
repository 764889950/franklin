#!/usr/bin/python
# vim: set foldmethod=marker :

import printer3d
import sys
import time
import gui

p = printer3d.Printer ()

def axis_test_single (axis, steps_per_s, use_min, slow, neg): # {{{
	# Move to the limit switch at slow speed.
	s = -1 if use_min else 1
	p.limits.clear ()
	# Go to the switch.
	p.run_axis (axis, s * slow)
	while len (p.limits) == 0:
		p.recv_packet (want_any = True)
	p.limits.clear ()
	p.axis[axis].set_current_pos (0)
	# We're at the switch now; move away a small distance.
	distance = 3200. / p.axis[axis].motor.steps_per_mm	# Move one rotation of the motor.
	epsilon = min (distance / 4, 5)
	back = neg if use_min else not neg
	if back:
		# Move away at high speed, then almost to it at low speed; if moving away failed, we'll hit the switch.
		p.goto (axes = {axis: -s * distance}, f0 = steps_per_s / (distance * p.axis[axis].motor.steps_per_mm))
		# Try moving to the switch again (actually epsilon mm before it).
		p.goto (axes = {axis: -s * epsilon}, f0 = slow / ((distance - epsilon) * p.axis[axis].motor.steps_per_mm), cb = True)
	else:
		# Move away slowly, then fast almost to it, then slowly slightly through it; if the fast move failed, we won't hit the switch.
		p.goto (axes = {axis: -s * distance}, f0 = slow / (distance * p.axis[axis].motor.steps_per_mm))
		# Try moving to the switch again (actually epsilon mm before it).
		p.goto (axes = {axis: -s * epsilon}, f0 = steps_per_s / ((distance - epsilon) * p.axis[axis].motor.steps_per_mm))
		# And slowly through it.
		p.goto (axes = {axis: s * epsilon}, f0 = slow / (2 * epsilon * p.axis[axis].motor.steps_per_mm), cb = True)
	while p.movewait > 0:
		p.recv_packet (want_any = True)
	print p.limits
	if back:
		return axis not in p.limits
	else:
		return axis in p.limits
# }}}
def axis_test_half (axis, neg): # {{{
	# Binary search for maximum steps per second.
	assert p.axis[axis].limit_min_pin < 255 or p.axis[axis].limit_max_pin < 255
	lower = 3200. # 1 revolution per second
	upper = lower * 2
	use_min = p.axis[axis].limit_min_pin < 255
	# Find real upper bound.
	while axis_test_single (axis, upper, use_min, 3200., neg):
		lower = upper
		upper *= 2
	slow = lower / 10
	lower /= 1.5	# Just to be sure.
	upper *= 1.5	# Just to be sure.
	# Continue until we have a value within 10%.
	while upper / lower - 1. > .1:
		mid = (lower + upper) / 2
		# Try this value.
		if axis_test_single (axis, mid, use_min, 3200., neg):
			lower = (mid + lower) / 2
		else:
			upper = (mid + upper) / 2
	return upper / 4	# Be safe and set the limit well below the "missing steps"-limit.
# }}}
def axis_test (axis): # {{{
	p.axis[axis].motor.max_f_neg = float ('inf')	# Discard old max speed.
	p.axis[axis].motor.max_f_pos = float ('inf')	# Discard old max speed.
	p.write_axis (axis)
	p.axis[axis].motor.max_f_neg = axis_test_half (axis, False)
	p.write_axis (axis)
	p.axis[axis].motor.max_f_pos = axis_test_half (axis, True)
	p.write_axis (axis)
	print ('result for axis %d: %f, %f mm/s' % (axis, p.axis[axis].motor.max_f_neg / p.axis[axis].motor.steps_per_mm, p.axis[axis].motor.max_f_pos / p.axis[axis].motor.steps_per_mm))
# }}}
def move_z_away (): # {{{
	if p.axis[2].limit_min_pin >= 255:
		return
	print p.axis[2].limit_max_pin
	# Move z out of the way.
	p.run_axis (2, -1)
	while len (p.limits) == 0:
		p.recv_packet (want_any = True)
	p.axis[2].set_current_pos (0)
	p.goto (axes = {2: 4}, f0 = 1. / 4, cb = True)
	while p.movewait != 0:
		p.recv_packet (want_any = True)
	p.sleep_axis (2)
# }}}
def calibrate_axis_speeds (): # Start easy: motors with endstops. {{{
	move_z_away ()
	for a in range (p.num_axes):
		axis_test (a)
		p.sleep_axis (a)
		p.save_axis (a)
# }}}

def do_calibrate_temps (temps, channels): # {{{
	cold = [p.readtemp (channel) for channel in channels]
	# In steps of 10 degrees, measure how much power is required to keep the temperature there.
	temp = (int (max (cold) / 10) + 1) * 10
	while temp <= 250:
		current_channels = [x for x in channels if temp < 130 or x < 2 + p.maxaxes + p.maxextruders]
		for c in current_channels:
			p.settemp (c, temp)
		# Wait for it to stabelize
		t = time.time ()
		while time.time () < t + 10:
			p.recv_packet (want_any = True, end_time = t + 10)
		# Measure the power
		result = []
		for c in current_channels:
			p.power_start (c)
		t = time.time ()
		while time.time () < t + 10:
			p.recv_packet (want_any = True)
		for c in current_channels:
			result.append ((c, p.power_end (c)))
		print ('%d: %s' % (temp, ' '.join (['%d:%f' % x for x in result])))
		temp += 10
# }}}
def calibrate_temps (): # Then temperature sensors. {{{
	temps = []
	channels = []
	for e in range (p.maxextruders):
		if p.extruder[e].temp.thermistor_pin < 255 and p.extruder[e].temp.power_pin < 255:
			temps.append (p.extruder[e].temp)
			channels.append (2 + p.maxaxes + e)
	for t in range (p.maxtemps):
		if p.temp[t].thermistor_pin < 255 and p.temp[t].power_pin < 255:
			temps.append (p.temp[t])
			channels.append (2 + p.maxaxes + p.maxextruders + t)
	do_calibrate_temps (temps, channels)
# }}}

def set_ramps_pins (min_limits = None, max_limits = None): # {{{
	if min_limits is None and max_limits is None:
		min_limits = True
		max_limits = False
	elif min_limits is None:
		min_limits = not max_limits
	elif max_limits is None:
		max_limits = not min_limits
	p.led_pin = 13
	p.num_axes = 3
	p.axis[0].limit_min_pin = 3 if min_limits else 255
	p.axis[0].limit_max_pin = 2 if max_limits else 255
	p.axis[0].motor.step_pin = 54
	p.axis[0].motor.dir_pin = 55
	p.axis[0].motor.enable_pin = 38
	p.axis[1].limit_min_pin = 14 if min_limits else 255
	p.axis[1].limit_max_pin = 15 if max_limits else 255
	p.axis[1].motor.step_pin = 60
	p.axis[1].motor.dir_pin = 61
	p.axis[1].motor.enable_pin = 56
	p.axis[2].limit_min_pin = 18 if min_limits else 255
	p.axis[2].limit_max_pin = 19 if max_limits else 255
	p.axis[2].motor.step_pin = 46
	p.axis[2].motor.dir_pin = 48
	p.axis[2].motor.enable_pin = 62
	for a in range (3, p.maxaxes):
		p.axis[a].limit_min_pin = 255
		p.axis[a].limit_max_pin = 255
		p.axis[a].motor.step_pin = 255
		p.axis[a].motor.dir_pin = 255
		p.axis[a].motor.enable_pin = 255
	p.extruder[0].temp.power_pin = 10
	p.extruder[0].temp.thermistor_pin = 13
	p.extruder[0].motor.step_pin = 26
	p.extruder[0].motor.dir_pin = 28
	p.extruder[0].motor.enable_pin = 24
	# Set up second extruder pins no matter if it is used.
	p.extruder[1].temp.power_pin = 9
	p.extruder[1].temp.thermistor_pin = 15
	p.extruder[1].motor.step_pin = 36
	p.extruder[1].motor.dir_pin = 34
	p.extruder[1].motor.enable_pin = 30
	for e in range (2, p.maxextruders):
		p.extruder[e].temp.power_pin = 255
		p.extruder[e].temp.thermistor_pin = 255
		p.extruder[e].R0 = float ('nan')
		p.extruder[e].motor.step_pin = 255
		p.extruder[e].motor.dir_pin = 255
		p.extruder[e].motor.enable_pin = 255
	p.temp[0].power_pin = 8
	p.temp[0].thermistor_pin = 14
	# Set up fan pin no matter if it is used.
	p.temp[1].power_pin = 9
	p.temp[1].thermistor_pin = 255
	for t in range (1, p.maxtemps):
		p.temp[t].power_pin = 255
		p.temp[t].thermistor_pin = 255
# }}}
def set_melzi_pins (min_limits = None, max_limits = None): # {{{
	if min_limits is None and max_limits is None:
		min_limits = True
		max_limits = False
	elif min_limits is None:
		min_limits = not max_limits
	elif max_limits is None:
		max_limits = not min_limits
	assert not (max_limits and min_limits)
	p.led_pin = 28	# 27 according to Repetier?
	p.axis[0].limit_min_pin = 18 if min_limits else 255
	p.axis[0].limit_max_pin = 18 if max_limits else 255
	p.axis[0].motor.step_pin = 15
	p.axis[0].motor.dir_pin = 21
	p.axis[0].motor.enable_pin = 14
	p.axis[1].limit_min_pin = 19 if min_limits else 255
	p.axis[1].limit_max_pin = 19 if max_limits else 255
	p.axis[1].motor.step_pin = 22
	p.axis[1].motor.dir_pin = 23
	p.axis[1].motor.enable_pin = 14
	p.axis[2].limit_min_pin = 20 if min_limits else 255
	p.axis[2].limit_max_pin = 20 if max_limits else 255
	p.axis[2].motor.step_pin = 3
	p.axis[2].motor.dir_pin = 2
	p.axis[2].motor.enable_pin = 29	#26 according to Repetier?
	for a in range (3, p.maxaxes):
		p.axis[a].limit_min_pin = 255
		p.axis[a].limit_max_pin = 255
		p.axis[a].motor.step_pin = 255
		p.axis[a].motor.dir_pin = 255
		p.axis[a].motor.enable_pin = 255
	p.extruder[0].temp.power_pin = 13
	p.extruder[0].temp.thermistor_pin = 7
	p.extruder[0].motor.step_pin = 1
	p.extruder[0].motor.dir_pin = 0
	p.extruder[0].motor.enable_pin = 14
	for e in range (1, p.maxextruders):
		p.extruder[e].temp.power_pin = 255
		p.extruder[e].temp.thermistor_pin = 255
		p.extruder[e].motor.step_pin = 255
		p.extruder[e].motor.dir_pin = 255
		p.extruder[e].motor.enable_pin = 255
	p.temp[0].power_pin = 12	# Heated bed.
	p.temp[0].thermistor_pin = 6
	p.temp[1].power_pin = 4		# Fan.
	p.temp[1].thermistor_pin = 255
	for t in range (2, p.maxtemps):
		p.temp[t].power_pin = 255
		p.temp[t].thermistor_pin = 255
# }}}

# Set everything up for calibration. {{{
def setup ():
	if g.melzi:
		set_melzi_pins (g.melzi_min_limits)
	else:
		set_ramps_pins (g.ramps_min_limits, g.ramps_max_limits)
	p.room_T = 25.
	p.temp_limit = int (float (g.temp_limit) * 1000)
	p.motor_limit = int (float (g.motor_limit) * 1000)
	for a in range (p.maxaxes):
		p.axis[a].motor.max_f_neg = float ('inf')
		p.axis[a].motor.max_f_pos = float ('inf')
		p.axis[a].motor.steps_per_mm = float ('nan')
	for e in range (p.maxextruders):
		p.extruder[e].temp.beta = 3885.0342279785623
		p.extruder[e].temp.alpha = 10.056909432214743
		p.extruder[e].temp.core_C = float ('nan')
		p.extruder[e].temp.shell_C = float ('nan')
		p.extruder[e].temp.transfer = float ('nan')
		p.extruder[e].temp.radiation = float ('nan')
		p.extruder[e].temp.power = 12. ** 2 / 5.4
		# Different per hobbed bolt and possibly per filament; must be measured.
		# However, as an estimate:
		# Small gear has 9 teeth; large gear 47.  Radius of hobbing is approximately 3.2 mm (20/2pi).
		p.extruder[e].motor.steps_per_mm = 835 #(200 * 16.) / ((9. / 47) * 20)
		p.extruder[e].motor.max_f_neg = float ('inf')
		p.extruder[e].motor.max_f_pos = float ('inf')
	for t in range (p.maxtemps):
		p.temp[t].beta = float ('nan')
		p.temp[t].alpha = float ('nan')
		p.temp[t].core_C = float ('nan')
		p.temp[t].shell_C = float ('nan')
		p.temp[t].transfer = float ('nan')
		p.temp[t].radiation = float ('nan')
		p.temp[t].power = float ('nan')
	p.temp[0].beta = 3700.
	p.temp[0].alpha = 11.7
	p.temp[0].radiation = float ('nan')
	p.temp[0].power = 12. ** 2 / 1.6

def setup_prusa ():
	setup ()
	# x and y axis: 5 mm per tooth; 12 teeth per revolution; 200 steps per revolution; 16 microsteps per step.
	p.axis[0].motor.steps_per_mm = (200 * 16.) / (5 * 12)	# [steps/rev] / ([mm/t] * [t/rev]) = [steps/rev] / [mm/rev] = [steps/mm]
	p.axis[1].motor.steps_per_mm = (200 * 16.) / (5 * 12)
	# z axis: 1.25 mm per revolution, 200 steps per revolution; 16 microsteps per step.
	p.axis[2].motor.steps_per_mm = 200 * 16 / 1.25
	p.write_all ()

def setup_delta ():
	setup ()
	# all axis: 5 mm per tooth; 12 teeth per revolution; 200 steps per revolution; 16 microsteps per step.
	p.axis[0].motor.steps_per_mm = (200 * 16.) / (5 * 12)	# [steps/rev] / ([mm/t] * [t/rev]) = [steps/rev] / [mm/rev] = [steps/mm]
	p.axis[1].motor.steps_per_mm = (200 * 16.) / (5 * 12)
	p.axis[2].motor.steps_per_mm = (200 * 16.) / (5 * 12)
	p.write_all ()
# }}}

g = gui.Gui (events = {
		'set_prusa': setup_prusa,
		'set_delta': setup_delta,
		'calibrate_axis_speeds': calibrate_axis_speeds,
		'calibrate_temps': calibrate_temps,
		'save': p.save_all
	}, inputs = (
		'melzi',
		'melzi_min_limits',
		'ramps_min_limits',
		'ramps_max_limits',
		'motor_limit',
		'temp_limit'
	), outputs = ())

g ()
'''
	else:
		# Display current settings.
		print ('num axes: %d' % p.num_axes)
		print ('num extruders: %d' % p.num_extruders)
		print ('num temps: %d' % p.num_temps)
		print ('room temperature: %f' % p.room_T)
		print ('motor limit: %d ms' % p.motor_limit)
		print ('temp limit: %d ms' % p.temp_limit)
		for a in range (p.maxaxes):
			print ('Axis %d:' % a)
			print ('\tlimit pins: %d %d' % (p.axis[a].limit_min_pin, p.axis[a].limit_max_pin))
			print ('\tmotor pins: %d %d %d' % (p.axis[a].motor.step_pin, p.axis[a].motor.dir_pin, p.axis[a].motor.enable_pin))
			print ('\tmotor steps per mm: %f' % p.axis[a].motor.steps_per_mm)
			print ('\tmotor max steps per ms: %f, %f' % (p.axis[a].motor.max_f_neg, p.axis[a].motor.max_f_pos))
		for e in range (p.maxextruders):
			print ('extruder %d' % e)
			print ('\ttemp pins: %d %d' % (p.extruder[e].temp.power_pin, p.extruder[e].temp.thermistor_pin))
			print ('\ttemp settings: %f %f %f %f %f %f %f' % (p.extruder[e].temp.alpha, p.extruder[e].temp.beta, p.extruder[e].temp.core_C, p.extruder[e].temp.shell_C, p.extruder[e].temp.transfer, p.extruder[e].temp.radiation, p.extruder[e].temp.power))
			print ('\tmotor pins: %d %d %d' % (p.extruder[e].motor.step_pin, p.extruder[e].motor.dir_pin, p.extruder[e].motor.enable_pin))
			print ('\tmotor steps per mm: %f' % p.extruder[e].motor.steps_per_mm)
			print ('\tmotor max steps per ms: %f, %f' % (p.extruder[e].motor.max_f_neg, p.extruder[e].motor.max_f_pos))
		for t in range (p.maxtemps):
			print ('temp %d' % t)
			print ('\tpins: %d %d' % (p.temp[t].power_pin, p.temp[t].thermistor_pin))
			print ('\tsettings: %f %f %f %f %f %f %f' % (p.temp[t].alpha, p.temp[t].beta, p.temp[t].core_C, p.temp[t].shell_C, p.temp[t].transfer, p.temp[t].radiation, p.temp[t].power))
		for i in range (2 + p.maxaxes, 2 + p.maxaxes + p.maxextruders + p.maxtemps):
			print ('temp %d: %f' % (i, p.readtemp (i)))
'''
