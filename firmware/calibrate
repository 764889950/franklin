#!/usr/bin/python

import interface
import sys
import time

p = interface.Printer ()

def test_one (axis, steps_per_s, use_min, slow):
	# Move to the limit switch; assume 3200 steps per revolution.
	# This need not be right; we just need a safe estimate which gets us to the switch.
	s = -1 if use_min else 1
	p.run (axis + 2, s * slow)
	while len (p.limits) == 0:
		p.recv_packet (want_any = True)
	p.limits.clear ()
	# We're at the switch now; move away a small distance.
	distance = min (slow, 100)
	p.goto (axes = {axis: -s * distance}, f0 = slow / distance)
	# Try moving to the switch again.
	p.goto (axes = {axis: 1.03 * s * distance}, f0 = steps_per_s / p.axis[axis].motor.steps_per_mm / (1.03 * distance), cb = True)
	while p.movewait > 0:
		p.recv_packet (want_any = True)
	ret = len (p.limits) != 0
	print p.limits.values ()
	p.limits.clear ()
	return ret

def test (axis):
	# Binary search for maximum steps per second.
	assert p.axis[axis].limit_min_pin < 255 or p.axis[axis].limit_max_pin < 255
	lower = 3200. # 1 revolution per second
	upper = 10000.
	# Find real upper bound.
	while test_one (axis, upper, p.axis[axis].limit_min_pin < 255, lower * .8 / p.axis[axis].motor.steps_per_mm):
		lower = upper
		upper *= 2
	upper *= 1.5	# Just to be sure.
	# Continue until we have a value within .1%.
	while upper / lower - 1. > .001:
		mid = (lower + upper) / 2
		# Try this value.
		if test_one (axis, mid, p.axis[axis].limit_min_pin < 255, lower * .8 / p.axis[axis].motor.steps_per_mm):
			lower = (mid + lower) / 2
		else:
			upper = (mid + upper) / 2
	print ('result for axis %d: %f mm/s' % (axis, upper / p.axis[axis].motor.steps_per_mm))
	return upper

def calibrate_temps (temps, channels):
	cold = []
	# Set up temp to return raw adc counts.
	for temp, channel in zip (temps, channels):
		temp.alpha = 0
		p.write (channel)
		# Save cold count; set cold temperature later.
		coldadc = sum ([p.readtemp (channel) for x in range (50)]) / 50
	# Heat it for 10 seconds, then let it cool for 30 seconds
	for temp, channel in zip (temps, channels):
		p.settemp (channel, float ('inf'))
	start = time.time ()
	measure = [[] for c in channels]
	while time.time () < start + 30:
		print time.time () - start
		for c, channel in enumerate (channels):
			measure[c].append ((time.time () - start, p.readtemp (channel)))
	for channel in channels:
		p.settemp (channel, float ('nan'))
	split = time.time () - start
	while time.time () < start + 330:
		for c, channel in enumerate (channels):
			measure[c].append ((time.time () - start, p.readtemp (channel)))
	# determine alpha, beta, R0, radiation and convection from last 30 seconds. (Is that possible?  Don't auto-calibrate alpha, beta and R0 for now.)
	# determine buffer_delay and power from first 10 seconds.
	# Step 1: dump all data to a file for manual inspection.
	with open ('/tmp/dump', 'w') as f:
		f.write ('# split: %f; channels: ' % split + ' '.join (['%d' % x for x in channels]) + '\n')
		f.write ('\n'.join ([' '.join (['%f %f' % measure[channel][row] for channel in range (len (channels))]) for row in range (len (measure[0]))]) + '\n')

# Start easy: motors with endstops.
if True:
	# Move z out of the way.
	p.run (4, -p.axis[2].motor.steps_per_mm)
	while len (p.limits) == 0:
		p.recv_packet (want_any = True)
	p.goto (z = 4, f0 = p.axis[2].motor.steps_per_mm / 4, cb = True)
	while p.movewait != 0:
		p.recv_packet (want_any = True)
	p.sleep (4)
	for a in range (3):
		p.axis[a].motor.max_f = float ('nan')	# Discard old max speed.
		p.write (a + 2)
		p.axis[a].motor.max_f = test (a) * .8	# Set it slightly lower, to be safe.
		p.sleep (a + 2)
		p.write (a + 2)
		p.save (a + 2)

# Then temperature sensors.
if False:
	temps = []
	channels = []
	if p.bed.thermistor_pin and p.bed.power_pin:
		temps.append (p.bed)
		channels.append (5)
	for e in range (p.num_extruders):
		temps.append (p.extruder[e].temp)
		channels.append (6 + e)
	calibrate_temps (temps, channels)
