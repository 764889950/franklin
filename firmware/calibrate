#!/usr/bin/python
# vim: set foldmethod=marker :

import interface
import sys
import time

p = interface.Printer ()

def test_one (axis, steps_per_s, use_min, slow, back): # {{{
	# Move to the limit switch at slow speed.
	s = -1 if use_min else 1
	p.limits.clear ()
	p.run (axis + 2, float ('inf') if back else s * slow)
	while len (p.limits) == 0:
		p.recv_packet (want_any = True)
	print 'start', p.limits.values ()
	p.limits.clear ()
	# We're at the switch now; move away a small distance.
	distance = min (slow / p.axis[axis].motor.steps_per_mm, 100)	# Move one second or 100 mm, whichever is less.
	p.axis[axis].set_current_pos (0)
	epsilon = min (distance / 2, 20)
	if back:
		p.goto (axes = {axis: -s * distance}, f0 = steps_per_s / (distance * p.axis[axis].motor.steps_per_mm))
		# Try moving to the switch again (actually epsilon mm before it).
		p.goto (axes = {axis: -s * epsilon}, cb = True)
	else:
		p.goto (axes = {axis: -s * distance}, f0 = slow / (distance * p.axis[axis].motor.steps_per_mm))
		# Try moving to the switch again (actually epsilon mm through it).
		p.goto (axes = {axis: epsilon * s}, f0 = steps_per_s / ((distance + epsilon) * p.axis[axis].motor.steps_per_mm), cb = True)
	while p.movewait > 0:
		p.recv_packet (want_any = True)
	print p.limits.values ()
	return len (p.limits) != 0
# }}}

def test (axis): # {{{
	# Binary search for maximum steps per second.
	assert p.axis[axis].limit_min_pin < 255 or p.axis[axis].limit_max_pin < 255
	lower = 3200. # 1 revolution per second
	upper = 10000.
	# Find real upper bound.
	while test_one (axis, upper, p.axis[axis].limit_min_pin < 255, lower * .2, False):
		lower = upper
		upper *= 2
	slow = lower * .2
	lower /= 1.5	# Just to be sure.
	upper *= 1.5	# Just to be sure.
	# Continue until we have a value within .1%.
	while upper / lower - 1. > .001:
		mid = (lower + upper) / 2
		# Try this value.
		if test_one (axis, mid, p.axis[axis].limit_min_pin < 255, slow, False):
			lower = (mid + lower) / 2
		else:
			upper = (mid + upper) / 2
	upper1 = upper
	# Then find the value for other direction.
	lower = slow / .2
	upper = lower * 2
	while test_one (axis, upper, p.axis[axis].limit_min_pin < 255, lower * .2, True):
		lower = upper
		upper *= 2
	lower /= 1.5	# Just to be sure.
	upper *= 1.5	# Just to be sure.
	while upper / lower - 1. > .001:
		mid = (lower + upper) / 2
		# Try this value.
		if test_one (axis, mid, p.axis[axis].limit_min_pin < 255, slow, True):
			lower = (mid + lower) / 2
		else:
			upper = (mid + upper) / 2
	print ('result for axis %d: %f, %f mm/s' % (axis, upper1 / p.axis[axis].motor.steps_per_mm, upper / p.axis[axis].motor.steps_per_mm))
	return upper1, upper
# }}}

def calibrate_temps (temps, channels): # {{{
	cold = []
	# Set up temp to return raw adc counts.
	for temp, channel in zip (temps, channels):
		temp.alpha = 0
		p.write (channel)
		# Save cold count; set cold temperature later.
		coldadc = sum ([p.readtemp (channel) for x in range (50)]) / 50
	# Heat it for 10 seconds, then let it cool for 30 seconds
	for temp, channel in zip (temps, channels):
		p.settemp (channel, float ('inf'))
	start = time.time ()
	measure = [[] for c in channels]
	while time.time () < start + 30:
		print time.time () - start
		for c, channel in enumerate (channels):
			measure[c].append ((time.time () - start, p.readtemp (channel)))
	for channel in channels:
		p.settemp (channel, float ('nan'))
	split = time.time () - start
	while time.time () < start + 330:
		for c, channel in enumerate (channels):
			measure[c].append ((time.time () - start, p.readtemp (channel)))
	# determine alpha, beta, R0, radiation and convection from last 30 seconds. (Is that possible?  Don't auto-calibrate alpha, beta and R0 for now.)
	# determine buffer_delay and power from first 10 seconds.
	# Step 1: dump all data to a file for manual inspection.
	with open ('/tmp/dump', 'w') as f:
		f.write ('# split: %f; channels: ' % split + ' '.join (['%d' % x for x in channels]) + '\n')
		f.write ('\n'.join ([' '.join (['%f %f' % measure[channel][row] for channel in range (len (channels))]) for row in range (len (measure[0]))]) + '\n')
# }}}

# Start easy: motors with endstops. {{{
if True:
	# Move z out of the way.
	p.run (4, -p.axis[2].motor.steps_per_mm)
	while len (p.limits) == 0:
		p.recv_packet (want_any = True)
	p.axis[2].set_current_pos (0)
	p.goto (axes = {2: 4}, f0 = 1. / 4, cb = True)
	while p.movewait != 0:
		p.recv_packet (want_any = True)
	p.sleep (2 + 2)
	for a in range (p.num_axes):
		p.axis[a].motor.max_f_neg = float ('inf')	# Discard old max speed.
		p.axis[a].motor.max_f_pos = float ('inf')	# Discard old max speed.
		p.write_axis (a)
		p.axis[a].motor.max_f_neg, p.axis[a].motor.max_f_pos = test (a) * .8	# Set it slightly lower, to be safe.
		p.sleep (a + 2)
		p.write_axis (a)
		p.save_axis (a)
# }}}

# Then temperature sensors. {{{
if False:
	temps = []
	channels = []
	if p.bed.thermistor_pin and p.bed.power_pin:
		temps.append (p.bed)
		channels.append (5)
	for e in range (p.num_extruders):
		temps.append (p.extruder[e].temp)
		channels.append (6 + e)
	calibrate_temps (temps, channels)
# }}}
