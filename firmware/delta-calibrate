#!/usr/bin/python

import sys
import gtk
import printer3d
import scipy.optimize

class App (gtk.EventBox):
	xs = [99.5, 199.0]	# Distances from center of calibration circles.
	txt_make_vertical = 'Make the axis vertical'
	txt_set_reference = 'position the center marker under the reference point'
	txt_move_to_next_point = 'Move the reference point above the next position'
	txt_move_to_bed = 'Move the reference point to the reference plane'
	def __init__ (self):
		super (App, self).__init__ ()
		self.control = False
		self.shift = False
		self.axis = 0
		self.phase = 1
		self.point = 0
		self.z = 0.
		self.zs = []
		self.other = 0.
		self.skew = 0.
		self.axisinfo = []
		self.add_events (gtk.gdk.KEY_PRESS_MASK | gtk.gdk.KEY_RELEASE_MASK)
		self.connect ('key_press_event', self.press)
		self.connect ('key_release_event', self.release)
		self.set_can_focus (True)
		self.label = gtk.Label (self.txt_make_vertical)
		self.set_size_request (600, 400)
		self.add (self.label)
		self.label.show ()
	def start (self):
		self.printer = printer3d.Printer ()
		self.home ()
		self.printer.motor_limit = 0
		self.printer.printer_type = 0
		self.printer.write_variables ()
		for i in range (3):
			self.printer.axis[i].motor.max_v_neg /= 2
			self.printer.axis[i].motor.max_v_pos /= 2
			self.printer.write_axis (i)
	def home (self):
		self.printer.limits.clear ()
		s = 1 if self.printer.axis[0].limit_max_pin < 255 else -1
		for i in range (3):
			self.printer.run_axis (i, s * 50)
		self.printer.wait_for_limits (3)
		self.printer.limits.clear ()
		for i in range (3):
			self.printer.axis[i].set_current_pos (0)
		self.printer.goto (axes = {0: s * -10, 1: s * -10, 2: s * -10}, cb = True)
		self.printer.wait_for_cb ()
		for i in range (3):
			self.printer.run_axis (i, s * 10)
		self.printer.wait_for_limits (3)
		self.printer.limits.clear ()
		for i in range (3):
			self.printer.axis[i].set_current_pos (0)
	def get_amount (self):
		if self.control:
			return .1
		if self.shift:
			return 10
		return 1
	def move (self, dz, dother, dskew):
		if self.phase > 1 or self.point == 1:
			dz = 0
		if self.point != 0:
			dskew = 0
		self.z += dz
		self.other += dother
		self.skew += dskew
		axes = {0: self.other, 1: self.other, 2: self.other}
		if self.axis >= 0:
			axes[self.axis] += self.z
			axes[(self.axis + 1) % 3] += self.skew
			axes[(self.axis + 2) % 3] -= self.skew
		if started:
			self.printer.goto (axes = axes)
	def topoint (self):
		c = self.zs[self.point]
		phase = self.phase
		point = self.point
		self.phase = 1
		self.point = 2
		self.move (0, 30, 0)
		if c[1] + 30 > self.other:
			self.move (0, c[1] + 30 - self.other, 0)
			self.move (c[0] - self.z, 0, 0)
		else:
			self.move (c[0] - self.z, 0, 0)
			self.move (0, c[1] + 30 - self.other, 0)
		self.point = point
		self.phase = phase
	def press (self, widget, event):
		if event.keyval == gtk.keysyms.Up:
			if self.point != 0:
				self.move (0, self.get_amount (), 0)
			else:
				self.move (-self.get_amount (), self.get_amount (), 0)
		elif event.keyval == gtk.keysyms.Down:
			if self.point != 0:
				self.move (0, -self.get_amount (), 0)
			else:
				self.move (self.get_amount (), -self.get_amount (), 0)
		elif event.keyval == gtk.keysyms.Left:
			if self.point != 0:
				self.move (self.get_amount (), 0, 0)
			else:
				self.move (0, 0, self.get_amount ())
		elif event.keyval == gtk.keysyms.Right:
			if self.point != 0:
				self.move (-self.get_amount (), 0, 0)
			else:
				self.move (0, 0, -self.get_amount ())
		elif event.keyval == gtk.keysyms.Shift_L:
			self.shift = True
		elif event.keyval == gtk.keysyms.Control_L:
			self.control = True
		elif event.keyval == gtk.keysyms.Return:
			print ('%d %5.1f %5.1f %3.1f' % (self.axis, self.z, self.other, self.skew))
			self.handle_data ()
	def release (self, widget, event):
		if event.keyval == gtk.keysyms.ISO_Prev_Group:
			self.shift = False
		elif event.keyval == gtk.keysyms.Control_L:
			self.control = False
	def quit (self, x):
		self.printer.motor_limit = 10000
		self.printer.write_variables ()
		gtk.main_quit ()
	def handle_data (self):
		self.point += 1
		if self.phase == 1:
			self.zs.append ((self.z, self.other))
			if len (self.zs) == len (self.xs) + 2:
				self.point = 1
				self.phase = 2
				self.topoint ()
				self.label.set_text (self.txt_move_to_bed)
			elif self.point == 1:
				self.label.set_text (self.txt_set_reference)
			else:
				self.label.set_text (self.txt_move_to_next_point)
			return
		if self.point < len (self.zs):
			self.topoint ()
			return
		z0 = self.zs[1][0] + self.zs[1][1]
		avg_l = 0
		for t, x in enumerate (self.xs):
			z = self.zs[t + 2][0] + self.zs[t + 2][1] - z0
			l = -z / 2 - x ** 2 / 2 / z
			print ('l = %f' % l)
			avg_l += l
		print ('average l = %f' % (avg_l / len (self.xs)))
		self.axisinfo.append ((z0, avg_l, self.zs[1][1] + self.skew, self.zs[1][1] - self.skew))
		self.zs = []
		self.point = 0
		self.phase = 1
		self.move (0, 10, 0)
		if self.z > self.other:
			self.move (0, -self.other / 2, 0)
			self.move (-self.z, 0, -self.skew)
		else:
			self.move (-self.z, 0, 0)
			self.move (0, -self.other / 2, -self.skew)
		self.axis += 1
		self.label.set_text (self.txt_make_vertical)
		if self.axis >= 3:
			def axislen (a, t):
				# Compute length from axis a to axis (a + t + 1) % 3
				b = (a + t + 1) % 3
				z = self.axisinfo[b][2 + t] - self.axisinfo[a][0]
				l = self.axisinfo[a][1]
				return (-z ** 2 - 2 * l * z) ** .5
			d = [[axislen (a, t) for t in range (2)] for a in range (3)]
			ad = [(d[t][0] + d[(t + 1) % 3][1]) / 2 for t in range (3)]
			print ('d = %s' % d)
			def cosrule (a, b, c):
				return b ** 2 + c ** 2 + b * c - a ** 2 # cos(120) == .5
			def errfunc (p):
				return [cosrule (ad[0], p[0], p[1]), cosrule (ad[1], p[1], p[2]), cosrule (ad[2], p[2], p[0])]
			# These values are correct for an equidistant triangle (and ad[*] are all equal there), which should be pretty close.
			p0 = [ad[0] * .5 * 3 ** .5, ad[1] * .5 * 3 ** .5, ad[2] *.5 * 3 ** .5]
			p1, success = scipy.optimize.leastsq (errfunc, p0[:])
			print ('Radii: %5.1f %5.1f %5.1f' % tuple (p1))
			zeropos = [self.axisinfo[a][0] + (self.axisinfo[a][1] ** 2 - p1[a] ** 2) ** .5 - self.axisinfo[a][1] for a in range (3)]
			print ('Zero positions: %s' % ', '.join (['%5.1f' % x for x in zeropos]))
			global started
			if not started:
				started = None
			else:
				for i in range (3):
					self.printer.axis[i].limit_max_pos = -zeropos[i]
					self.printer.axis[i].delta_length = self.axisinfo[i][1]
					self.printer.axis[i].delta_radius = p1[i]
					self.printer.write_axis (i)
					self.printer.save_axis (i)
				self.printer.printer_type = 1
				self.printer.write_variables ()
				self.printer.save_variables ()
				gtk.main_quit ()

w = gtk.Window ()
a = App ()
w.add (a)
w.connect ('destroy', a.quit)
a.show ()
w.show ()
started = False
if len (sys.argv) > 1:
	with open (sys.argv[1]) as f:
		for ln in f.readlines ():
			axis, a.z, a.other, a.skew = [float (x) for x in ln.split ()]
			a.handle_data ()
if started is not None:
	started = True
	a.start ()
	gtk.main ()
	for i in range (3):
		a.printer.sleep_axis (i)
